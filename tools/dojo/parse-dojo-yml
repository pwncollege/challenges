#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "pyyaml>=6.0",
#   "pydantic>=2.0",
# ]
# ///

import argparse
import datetime
import json
import pathlib
import re
import sys
from typing import Annotated, Literal, Optional, Union

import yaml
from pydantic import BaseModel, ConfigDict, Field, ValidationError, field_validator


ID_REGEX = re.compile(r"^[a-z0-9-]{1,32}$")

DOJO_ATTRS = ["id", "name", "type", "award", "description", "modules"]
MODULE_ATTRS = ["id", "name", "description", "resources"]

INHERIT_KEYS = ["image", "privileged", "allow_privileged", "importable", "interfaces"]

DOJO_ALLOWED_KEYS = set(DOJO_ATTRS) | set(INHERIT_KEYS) | {"visibility"}
MODULE_ALLOWED_KEYS = set(MODULE_ATTRS) | set(INHERIT_KEYS) | {"visibility"}


class Visibility(BaseModel):
    model_config = ConfigDict(extra="forbid")

    start: Optional[str] = None

    @field_validator("start")
    @classmethod
    def validate_start(cls, value: Optional[str]) -> Optional[str]:
        if value is not None:
            datetime.datetime.fromisoformat(value)
        return value


class ChallengeResource(BaseModel):
    model_config = ConfigDict(extra="forbid")

    type: Literal["challenge"]
    id: str = Field(pattern=r"^[a-z0-9-]{1,32}$")
    name: str

    description: Optional[str] = None
    required: Optional[bool] = None
    privileged: Optional[bool] = None
    allow_privileged: Optional[bool] = None
    importable: Optional[bool] = None
    progression_locked: Optional[bool] = None
    interfaces: Optional[list] = None
    image: Optional[str] = None
    visibility: Optional[Visibility] = None


class HeaderResource(BaseModel):
    model_config = ConfigDict(extra="forbid")

    type: Literal["header"]
    content: str
    visibility: Optional[Visibility] = None


class MarkdownResource(BaseModel):
    model_config = ConfigDict(extra="forbid")

    type: Literal["markdown"]
    name: str
    content: str

    expandable: bool = True
    visibility: Optional[Visibility] = None


class LectureResource(BaseModel):
    model_config = ConfigDict(extra="forbid")

    type: Literal["lecture"]
    name: str

    video: Optional[str] = None
    playlist: Optional[str] = None
    slides: Optional[str] = None
    visibility: Optional[Visibility] = None


Resource = Annotated[
    Union[ChallengeResource, HeaderResource, MarkdownResource, LectureResource],
    Field(discriminator="type"),
]


class ModuleSpec(BaseModel):
    model_config = ConfigDict(extra="forbid")

    id: str = Field(pattern=r"^[a-z0-9-]{1,32}$")
    name: str

    description: Optional[str] = None
    visibility: Optional[Visibility] = None

    resources: list[Resource]


class DojoSpec(BaseModel):
    model_config = ConfigDict(extra="forbid")

    id: str = Field(pattern=r"^[a-z0-9-]{1,32}$")
    name: str

    type: Optional[str] = None
    award: Optional[dict] = None
    description: Optional[str] = None
    visibility: Optional[Visibility] = None

    modules: list[ModuleSpec] = Field(min_length=1)


def read_yaml_mapping(path: pathlib.Path) -> dict:
    if not path.exists():
        return {}

    loaded = yaml.safe_load(path.read_text())
    if loaded is None:
        return {}

    if not isinstance(loaded, dict):
        raise ValueError(f"{path}: expected a mapping at the top level")

    return loaded


def forbid_extra_keys(where: str, data: dict, allowed: set):
    if extra := set(data) - allowed:
        raise ValueError(f"{where}: unsupported keys: {', '.join(sorted(extra))}")


def main() -> int:
    parser = argparse.ArgumentParser(description="Parse and validate dojo.yml into a Dojo update payload.")
    parser.add_argument("dojo_yml", type=pathlib.Path, help="Path to dojo.yml.")
    parser.add_argument("--json", action="store_true", help="Print the JSON payload to stdout.")
    args = parser.parse_args()

    dojo_yml = args.dojo_yml
    if not dojo_yml.exists():
        print(f"Skipping: no dojo.yml at {dojo_yml}", file=sys.stderr)
        return 0

    dojo_dir = dojo_yml.parent

    try:
        # Phase 1: read.
        dojo_data = yaml.safe_load(dojo_yml.read_text())
        if dojo_data is None:
            dojo_data = {}
        if not isinstance(dojo_data, dict):
            raise ValueError(f"{dojo_yml}: expected a mapping at the top level")

        dojo_description_md = None
        if (dojo_dir / "DESCRIPTION.md").exists():
            dojo_description_md = (dojo_dir / "DESCRIPTION.md").read_text()

        modules = dojo_data.get("modules")
        module_reads = []
        if isinstance(modules, list):
            for module_entry in modules:
                module_id = module_entry.get("id") if isinstance(module_entry, dict) else None
                module_dir = dojo_dir / module_id if isinstance(module_id, str) else None

                module_data = read_yaml_mapping(module_dir / "module.yml") if module_dir else {}

                module_description_md = None
                if module_dir and (module_dir / "DESCRIPTION.md").exists():
                    module_description_md = (module_dir / "DESCRIPTION.md").read_text()

                challenge_reads = {}
                resources = module_data.get("resources")
                if isinstance(resources, list) and module_dir:
                    for resource in resources:
                        if not isinstance(resource, dict) or resource.get("type") != "challenge":
                            continue

                        challenge_id = resource.get("id")
                        if not isinstance(challenge_id, str):
                            continue

                        challenge_dir = module_dir / challenge_id
                        challenge_data = read_yaml_mapping(challenge_dir / "challenge.yml")

                        challenge_description_md = None
                        if (challenge_dir / "DESCRIPTION.md").exists():
                            challenge_description_md = (challenge_dir / "DESCRIPTION.md").read_text()

                        challenge_reads[challenge_id] = (challenge_data, challenge_description_md)

                module_reads.append((module_entry, module_data, module_description_md, challenge_reads))

        # Phase 2: transform.
        dojo_id = dojo_data.get("id")
        dojo_name = dojo_data.get("name") or (dojo_id.replace("-", " ").title() if isinstance(dojo_id, str) else None)

        dojo_defaults = {key: dojo_data[key] for key in INHERIT_KEYS if key in dojo_data}

        parsed_modules = []
        for module_entry, module_data, module_description_md, challenge_reads in module_reads:
            module_id = module_entry.get("id") if isinstance(module_entry, dict) else None
            module_name = module_data.get("name") or (module_id.replace("-", " ").title() if isinstance(module_id, str) else None)

            module_defaults = {**dojo_defaults, **{key: module_data[key] for key in INHERIT_KEYS if key in module_data}}

            resources = module_data.get("resources", [])
            resources_out = []
            if isinstance(resources, list):
                for resource in resources:
                    if not isinstance(resource, dict):
                        resources_out.append(resource)
                        continue

                    if resource.get("type") == "challenge":
                        challenge_id = resource.get("id")
                        challenge_data, challenge_description_md = challenge_reads.get(challenge_id, ({}, None))

                        resource = {**challenge_data, **resource, "type": "challenge", "id": challenge_id}
                        resource.setdefault("name", challenge_id.replace("-", " ").title() if isinstance(challenge_id, str) else None)

                        if resource.get("description") is None:
                            resource["description"] = challenge_description_md

                        for key, value in module_defaults.items():
                            resource.setdefault(key, value)

                    resources_out.append(resource)
            else:
                resources_out = resources

            module_out = {
                "id": module_id,
                "name": module_name,
                "description": module_data.get("description") or module_description_md,
                "visibility": module_data.get("visibility"),
                "resources": resources_out,
            }

            module_out = {key: module_out[key] for key in MODULE_ATTRS + ["visibility"] if module_out.get(key) is not None}
            parsed_modules.append(module_out)

        spec = {
            "id": dojo_id,
            "name": dojo_name,
            "type": dojo_data.get("type"),
            "award": dojo_data.get("award"),
            "description": dojo_data.get("description") or dojo_description_md,
            "visibility": dojo_data.get("visibility"),
            "modules": parsed_modules,
        }

        spec = {key: spec[key] for key in DOJO_ATTRS + ["visibility"] if spec.get(key) is not None}

        # Phase 3: validate.
        forbid_extra_keys("dojo.yml", dojo_data, DOJO_ALLOWED_KEYS)

        if not isinstance(modules, list) or not modules:
            raise ValueError("dojo.yml.modules: expected a non-empty list")

        for module_index, (module_entry, module_data, _module_description_md, _challenge_reads) in enumerate(module_reads):
            where_module = f"dojo.yml.modules[{module_index}]"
            if not isinstance(module_entry, dict) or set(module_entry) != {"id"}:
                raise ValueError(f"{where_module}: expected a mapping with only id")

            module_id = module_entry["id"]
            if not isinstance(module_id, str) or not ID_REGEX.fullmatch(module_id):
                raise ValueError(f"{where_module}.id: expected /^[a-z0-9-]{{1,32}}$/")

            forbid_extra_keys(f"{module_id}/module.yml", module_data, MODULE_ALLOWED_KEYS)

        try:
            validated = DojoSpec.model_validate(spec)
        except ValidationError as error:
            for entry in error.errors():
                loc = ".".join(str(part) for part in entry.get("loc", []))
                message = entry.get("msg", "invalid")
                print(f"Error: {loc}: {message}", file=sys.stderr)
            return 1

        spec = validated.model_dump(mode="json", exclude_none=True)

    except Exception as error:
        print(f"Error: failed to parse {dojo_yml}: {error}", file=sys.stderr)
        return 1

    print(f"Parsed successfully: dojo={dojo_id}", file=sys.stderr)

    if args.json:
        print(json.dumps(spec, indent=2, sort_keys=False))

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
