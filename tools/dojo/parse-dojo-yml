#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "pyyaml>=6.0",
# ]
# ///

import argparse
import datetime
import json
import pathlib
import re
import sys

import yaml


ID_REGEX = re.compile(r"^[a-z0-9-]{1,32}$")

RESOURCE_SPECS = {
    "challenge": {
        "required": {"id": str, "name": str},
        "optional": {"description": str, "required": bool, "privileged": bool, "allow_privileged": bool, "importable": bool, "progression_locked": bool, "interfaces": list, "image": str},
        "defaults": {},
    },
    "header": {"required": {"content": str}, "optional": {}, "defaults": {}},
    "markdown": {"required": {"name": str, "content": str}, "optional": {"expandable": bool}, "defaults": {"expandable": True}},
    "lecture": {"required": {"name": str}, "optional": {"video": str, "playlist": str, "slides": str}, "defaults": {}},
}


def read_yaml_mapping(path: pathlib.Path) -> dict:
    if not path.exists():
        return {}
    loaded = yaml.safe_load(path.read_text())
    if loaded is None:
        return {}
    if not isinstance(loaded, dict):
        raise ValueError(f"{path}: expected a mapping at the top level")
    return loaded


def parse_visibility(visibility: object, where: str) -> dict | None:
    if visibility is None:
        return None
    if not isinstance(visibility, dict):
        raise ValueError(f"{where}: expected mapping")
    if extra := set(visibility) - {"start", "stop"}:
        raise ValueError(f"{where}: unsupported keys: {', '.join(sorted(extra))}")
    out = {}
    for key in ("start", "stop"):
        if key not in visibility:
            continue
        value = visibility[key]
        if not isinstance(value, str):
            raise ValueError(f"{where}.{key}: expected ISO string")
        datetime.datetime.fromisoformat(value)
        out[key] = value
    return out


def validate_resource(where: str, resource: dict, defaults: dict) -> dict:
    resource_type = resource.get("type")
    if not isinstance(resource_type, str):
        raise ValueError(f"{where}.type: expected string")

    if resource_type not in RESOURCE_SPECS:
        raise ValueError(f"{where}.type: unsupported type {resource_type!r}")

    spec = RESOURCE_SPECS[resource_type]
    required = spec["required"]
    optional = spec["optional"]
    type_defaults = spec["defaults"]

    allowed = {"type", "visibility"} | set(required) | set(optional) | set(type_defaults)
    if extra := set(resource) - allowed:
        raise ValueError(f"{where}: unsupported keys: {', '.join(sorted(extra))}")

    out = {"type": resource_type}

    for key, expected_type in required.items():
        value = resource.get(key)
        if not isinstance(value, expected_type):
            raise ValueError(f"{where}.{key}: expected {expected_type.__name__}")
        out[key] = value

    for key, expected_type in optional.items():
        if key in resource:
            value = resource[key]
            if not isinstance(value, expected_type):
                raise ValueError(f"{where}.{key}: expected {expected_type.__name__}")
            out[key] = value
        elif key in type_defaults:
            out[key] = type_defaults[key]

    if resource_type == "challenge":
        for key, value in defaults.items():
            if key in out or key not in optional:
                continue
            if not isinstance(value, optional[key]):
                raise ValueError(f"{where}.{key}: expected {optional[key].__name__}")
            out[key] = value

    if (visibility := parse_visibility(resource.get("visibility"), f"{where}.visibility")) is not None:
        out["visibility"] = visibility

    return out


def main() -> int:
    parser = argparse.ArgumentParser(description="Parse and validate dojo.yml into a Dojo update payload.")
    parser.add_argument("dojo_yml", type=pathlib.Path, help="Path to dojo.yml.")
    parser.add_argument("--json", action="store_true", help="Print the JSON payload to stdout.")
    args = parser.parse_args()

    dojo_yml = args.dojo_yml
    if not dojo_yml.exists():
        print(f"Skipping: no dojo.yml at {dojo_yml}", file=sys.stderr)
        return 0

    dojo_dir = dojo_yml.parent

    try:
        dojo_data = yaml.safe_load(dojo_yml.read_text())
        if not isinstance(dojo_data, dict):
            raise ValueError(f"{dojo_yml}: expected a mapping at the top level")

        dojo_id = dojo_data.get("id")
        if not isinstance(dojo_id, str) or not ID_REGEX.fullmatch(dojo_id):
            raise ValueError("dojo.yml.id: expected /^[a-z0-9-]{1,32}$/")

        dojo_name = dojo_data.get("name") or dojo_id.replace("-", " ").title()

        modules = dojo_data.get("modules")
        if not isinstance(modules, list) or not modules:
            raise ValueError("dojo.yml.modules: expected a non-empty list")

        dojo_defaults = {key: dojo_data[key] for key in ["privileged", "allow_privileged", "importable", "interfaces"] if key in dojo_data}

        parsed_modules = []
        for module_index, module_entry in enumerate(modules):
            where_module = f"dojo.yml.modules[{module_index}]"
            if not isinstance(module_entry, dict):
                raise ValueError(f"{where_module}: expected mapping")

            module_id = module_entry.get("id")
            if not isinstance(module_id, str) or not ID_REGEX.fullmatch(module_id):
                raise ValueError(f"{where_module}.id: expected /^[a-z0-9-]{{1,32}}$/")

            module_dir = dojo_dir / module_id
            module_data = read_yaml_mapping(module_dir / "module.yml")
            module_resources = module_data.get("resources") or []
            if not isinstance(module_resources, list):
                raise ValueError(f"{module_dir}/module.yml.resources: expected list")

            module_defaults = {**dojo_defaults, **{key: module_data[key] for key in ["privileged", "allow_privileged", "importable", "interfaces"] if key in module_data}}

            challenge_reads = {}
            for resource in module_resources:
                if not isinstance(resource, dict) or resource.get("type") != "challenge":
                    continue
                challenge_id = resource.get("id")
                if isinstance(challenge_id, str):
                    challenge_dir = module_dir / challenge_id
                    challenge_reads[challenge_id] = (read_yaml_mapping(challenge_dir / "challenge.yml"), (challenge_dir / "DESCRIPTION.md").read_text() if (challenge_dir / "DESCRIPTION.md").exists() else None)

            module_name = module_data.get("name") or module_id.replace("-", " ").title()
            module_description = module_data.get("description") or ((module_dir / "DESCRIPTION.md").read_text() if (module_dir / "DESCRIPTION.md").exists() else None)

            resources_out = []
            for resource_index, resource in enumerate(module_resources):
                where = f"{module_id}/module.yml.resources[{resource_index}]"
                if not isinstance(resource, dict):
                    raise ValueError(f"{where}: expected mapping")

                if resource.get("type") != "challenge":
                    resources_out.append(validate_resource(where, resource, {}))
                    continue

                challenge_id = resource.get("id")
                if not isinstance(challenge_id, str) or not ID_REGEX.fullmatch(challenge_id):
                    raise ValueError(f"{where}.id: expected /^[a-z0-9-]{{1,32}}$/")

                challenge_yml, challenge_desc = challenge_reads.get(challenge_id, ({}, None))
                challenge_data = {**challenge_yml, **resource, "id": challenge_id}
                challenge_data.setdefault("name", challenge_id.replace("-", " ").title())
                if challenge_data.get("description") is None and challenge_desc is not None:
                    challenge_data["description"] = challenge_desc

                resources_out.append(validate_resource(where, challenge_data, module_defaults))

            module_out = {"id": module_id, "name": module_name, "resources": resources_out}
            if module_description is not None:
                module_out["description"] = module_description
            parsed_modules.append(module_out)

        spec = {"id": dojo_id, "name": dojo_name, "modules": parsed_modules}
        for key in ["type", "description", "award"]:
            if key in dojo_data:
                spec[key] = dojo_data[key]

    except Exception as error:
        print(f"Error: failed to parse {dojo_yml}: {error}", file=sys.stderr)
        return 1

    print(f"Parsed successfully: dojo={dojo_id}", file=sys.stderr)
    if args.json:
        print(json.dumps(spec, indent=2, sort_keys=False))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
