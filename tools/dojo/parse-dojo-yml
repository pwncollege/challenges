#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "pyyaml>=6.0",
# ]
# ///

import argparse
import datetime
import json
import pathlib
import re
import sys

import yaml


ID_REGEX = re.compile(r"^[a-z0-9-]{1,32}$")

RESOURCE_SPECS = {
    "challenge": {
        "required": {"id": str, "name": str},
        "optional": {"description": str, "required": bool, "privileged": bool, "allow_privileged": bool, "importable": bool, "progression_locked": bool, "interfaces": list, "image": str},
        "defaults": {},
    },
    "header": {"required": {"content": str}, "optional": {}, "defaults": {}},
    "markdown": {"required": {"name": str, "content": str}, "optional": {"expandable": bool}, "defaults": {"expandable": True}},
    "lecture": {"required": {"name": str}, "optional": {"video": str, "playlist": str, "slides": str}, "defaults": {}},
}

DOJO_KEYS = {"id", "name", "type", "description", "award", "image", "privileged", "allow_privileged", "importable", "interfaces", "visibility", "modules"}
MODULE_KEYS = {"id", "name", "description", "image", "privileged", "allow_privileged", "importable", "interfaces", "visibility", "resources", "challenges"}
PASSTHRU_KEYS = ("type", "award", "description", "image", "privileged", "allow_privileged", "importable", "interfaces", "visibility")


def read_yaml_mapping(path: pathlib.Path) -> dict:
    if not path.exists():
        return {}
    loaded = yaml.safe_load(path.read_text()) or {}
    if not isinstance(loaded, dict):
        raise ValueError(f"{path}: expected a mapping at the top level")
    return loaded


def parse_visibility(where: str, visibility: object):
    if visibility is None:
        return None
    if not isinstance(visibility, dict):
        raise ValueError(f"{where}: expected mapping")
    if extra := set(visibility) - {"start", "stop"}:
        raise ValueError(f"{where}: unsupported keys: {', '.join(sorted(extra))}")
    out = {}
    for key in ("start", "stop"):
        if key not in visibility:
            continue
        value = visibility[key]
        if not isinstance(value, str):
            raise ValueError(f"{where}.{key}: expected ISO string")
        datetime.datetime.fromisoformat(value)
        out[key] = value
    return out


def main() -> int:
    parser = argparse.ArgumentParser(description="Parse and validate dojo.yml into a Dojo update payload.")
    parser.add_argument("dojo_yml", type=pathlib.Path, help="Path to dojo.yml.")
    parser.add_argument("--json", action="store_true", help="Print the JSON payload to stdout.")
    args = parser.parse_args()

    dojo_yml = args.dojo_yml
    if not dojo_yml.exists():
        print(f"Skipping: no dojo.yml at {dojo_yml}", file=sys.stderr)
        return 0

    dojo_dir = dojo_yml.parent

    try:
        dojo_data = yaml.safe_load(dojo_yml.read_text()) or {}
        if not isinstance(dojo_data, dict):
            raise ValueError(f"{dojo_yml}: expected a mapping at the top level")

        if extra := set(dojo_data) - DOJO_KEYS:
            raise ValueError(f"dojo.yml: unsupported keys: {', '.join(sorted(extra))}")

        dojo_id = dojo_data.get("id")
        if not isinstance(dojo_id, str) or not ID_REGEX.fullmatch(dojo_id):
            raise ValueError("dojo.yml.id: expected /^[a-z0-9-]{1,32}$/")

        dojo_name = dojo_data.get("name") or dojo_id.replace("-", " ").title()

        modules = dojo_data.get("modules")
        if not isinstance(modules, list) or not modules:
            raise ValueError("dojo.yml.modules: expected a non-empty list")

        parsed_modules = []
        for module_index, module_entry in enumerate(modules):
            where_module = f"dojo.yml.modules[{module_index}]"
            if not isinstance(module_entry, dict) or set(module_entry) != {"id"}:
                raise ValueError(f"{where_module}: expected a mapping with only id")

            module_id = module_entry.get("id")
            if not isinstance(module_id, str) or not ID_REGEX.fullmatch(module_id):
                raise ValueError(f"{where_module}.id: expected /^[a-z0-9-]{{1,32}}$/")

            module_dir = dojo_dir / module_id
            module_data = read_yaml_mapping(module_dir / "module.yml")

            if extra := set(module_data) - MODULE_KEYS:
                raise ValueError(f"{module_dir}/module.yml: unsupported keys: {', '.join(sorted(extra))}")

            if "challenges" in module_data:
                raise ValueError(f"{module_dir}/module.yml: 'challenges' is no longer supported; convert to resources entries")

            module_resources = module_data.get("resources") or []
            if not isinstance(module_resources, list):
                raise ValueError(f"{module_dir}/module.yml.resources: expected list")

            module_name = module_data.get("name") or module_id.replace("-", " ").title()
            module_description = module_data.get("description")
            if module_description is None and (desc_path := module_dir / "DESCRIPTION.md").exists():
                module_description = desc_path.read_text()

            resources_out = []
            for resource_index, resource in enumerate(module_resources):
                where = f"{module_id}/module.yml.resources[{resource_index}]"
                if not isinstance(resource, dict):
                    raise ValueError(f"{where}: expected mapping")

                resource_type = resource.get("type")
                if not isinstance(resource_type, str) or resource_type not in RESOURCE_SPECS:
                    raise ValueError(f"{where}.type: expected one of {', '.join(RESOURCE_SPECS)}")

                resource_data = dict(resource)
                if resource_type == "challenge":
                    challenge_id = resource.get("id")
                    if not isinstance(challenge_id, str) or not ID_REGEX.fullmatch(challenge_id):
                        raise ValueError(f"{where}.id: expected /^[a-z0-9-]{{1,32}}$/")

                    challenge_dir = module_dir / challenge_id
                    challenge_data = read_yaml_mapping(challenge_dir / "challenge.yml")
                    resource_data = {**challenge_data, **resource_data, "type": "challenge", "id": challenge_id}
                    resource_data.setdefault("name", challenge_id.replace("-", " ").title())
                    if resource_data.get("description") is None and (desc_path := challenge_dir / "DESCRIPTION.md").exists():
                        resource_data["description"] = desc_path.read_text()

                if (visibility := parse_visibility(f"{where}.visibility", resource_data.get("visibility"))) is not None:
                    resource_data["visibility"] = visibility

                spec = RESOURCE_SPECS[resource_type]
                for key, value in spec["defaults"].items():
                    resource_data.setdefault(key, value)

                required = spec["required"]
                optional = spec["optional"]
                allowed = {"type", "visibility"} | set(required) | set(optional) | set(spec["defaults"])

                if extra := set(resource_data) - allowed:
                    raise ValueError(f"{where}: unsupported keys: {', '.join(sorted(extra))}")

                out = {"type": resource_type}
                for key, expected_type in required.items():
                    value = resource_data.get(key)
                    if not isinstance(value, expected_type):
                        raise ValueError(f"{where}.{key}: expected {expected_type.__name__}")
                    out[key] = value
                for key, expected_type in optional.items():
                    if key not in resource_data:
                        continue
                    value = resource_data[key]
                    if not isinstance(value, expected_type):
                        raise ValueError(f"{where}.{key}: expected {expected_type.__name__}")
                    out[key] = value

                if "visibility" in resource_data:
                    out["visibility"] = resource_data["visibility"]

                resources_out.append(out)

            module_out = {"id": module_id, "name": module_name, "resources": resources_out}
            if module_description is not None:
                module_out["description"] = module_description
            module_out.update({key: module_data[key] for key in PASSTHRU_KEYS if key in module_data})

            parsed_modules.append(module_out)

        spec = {"id": dojo_id, "name": dojo_name, "modules": parsed_modules}
        spec.update({key: dojo_data[key] for key in PASSTHRU_KEYS if key in dojo_data})

    except Exception as error:
        print(f"Error: failed to parse {dojo_yml}: {error}", file=sys.stderr)
        return 1

    print(f"Parsed successfully: dojo={dojo_id}", file=sys.stderr)
    if args.json:
        print(json.dumps(spec, indent=2, sort_keys=False))
    return 0
if __name__ == "__main__":
    raise SystemExit(main())
