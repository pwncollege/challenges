#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "pyyaml>=6.0",
# ]
# ///

import argparse
import datetime
import json
import pathlib
import re
import sys

import yaml


ID_REGEX = re.compile(r"^[a-z0-9-]{1,32}$")
NAME_REGEX = re.compile(r"^[\S ]{1,128}$")


def main() -> int:
    parser = argparse.ArgumentParser(description="Parse and validate dojo.yml into a Dojo update payload.")
    parser.add_argument("dojo_yml", type=pathlib.Path, help="Path to dojo.yml.")
    parser.add_argument("--json", action="store_true", help="Print the JSON payload to stdout.")
    args = parser.parse_args()

    dojo_yml = args.dojo_yml
    if not dojo_yml.exists():
        print(f"Skipping: no dojo.yml at {dojo_yml}", file=sys.stderr)
        return 0

    dojo_dir = dojo_yml.parent

    try:
        dojo_data = yaml.safe_load(dojo_yml.read_text())
        if not isinstance(dojo_data, dict):
            raise ValueError(f"{dojo_yml}: expected a mapping at the top level")

        allowed_dojo_keys = {
            "id",
            "name",
            "type",
            "award",
            "modules",
            "description",
            "privileged",
            "allow_privileged",
            "importable",
            "interfaces",
        }
        if extra := set(dojo_data.keys()) - allowed_dojo_keys:
            raise ValueError(f"dojo.yml: unsupported keys: {', '.join(sorted(extra))}")

        dojo_id = dojo_data.get("id")
        if not isinstance(dojo_id, str) or not ID_REGEX.fullmatch(dojo_id):
            raise ValueError("dojo.yml.id: expected /^[a-z0-9-]{1,32}$/")

        dojo_name = dojo_data.get("name") or dojo_id.replace("-", " ").title()
        if not isinstance(dojo_name, str) or not NAME_REGEX.fullmatch(dojo_name):
            raise ValueError("dojo.yml.name: invalid name")

        dojo_type = dojo_data.get("type")
        if dojo_type is not None and (not isinstance(dojo_type, str) or not ID_REGEX.fullmatch(dojo_type)):
            raise ValueError("dojo.yml.type: expected /^[a-z0-9-]{1,32}$/")

        dojo_description = dojo_data.get("description")
        if dojo_description is not None and not isinstance(dojo_description, str):
            raise ValueError("dojo.yml.description: expected string")

        dojo_award = dojo_data.get("award")
        if dojo_award is not None:
            if not isinstance(dojo_award, dict):
                raise ValueError("dojo.yml.award: expected mapping")
            if extra := set(dojo_award.keys()) - {"emoji", "belt"}:
                raise ValueError(f"dojo.yml.award: unsupported keys: {', '.join(sorted(extra))}")
            if "emoji" in dojo_award and not isinstance(dojo_award["emoji"], str):
                raise ValueError("dojo.yml.award.emoji: expected string")
            if "belt" in dojo_award and not isinstance(dojo_award["belt"], str):
                raise ValueError("dojo.yml.award.belt: expected string")

        modules = dojo_data.get("modules")
        if not isinstance(modules, list) or not modules:
            raise ValueError("dojo.yml.modules: expected a non-empty list")

        parsed_modules = []
        for module_index, module_entry in enumerate(modules):
            where_module = f"dojo.yml.modules[{module_index}]"
            if not isinstance(module_entry, dict):
                raise ValueError(f"{where_module}: expected mapping")

            allowed_module_keys = {"id", "name", "description", "privileged", "allow_privileged", "importable", "interfaces"}
            if extra := set(module_entry.keys()) - allowed_module_keys:
                raise ValueError(f"{where_module}: unsupported keys: {', '.join(sorted(extra))}")

            module_id = module_entry.get("id")
            if not isinstance(module_id, str) or not ID_REGEX.fullmatch(module_id):
                raise ValueError(f"{where_module}.id: expected /^[a-z0-9-]{{1,32}}$/")

            module_dir = dojo_dir / module_id
            module_file_path = module_dir / "module.yml"
            if module_file_path.exists():
                module_file_data = yaml.safe_load(module_file_path.read_text()) or {}
                if not isinstance(module_file_data, dict):
                    raise ValueError(f"{module_file_path}: expected a mapping at the top level")
            else:
                module_file_data = {}

            module_data = {**module_file_data, **module_entry}

            allowed_module_data_keys = {"id", "name", "description", "challenges", "privileged", "allow_privileged", "importable", "interfaces"}
            if extra := set(module_data.keys()) - allowed_module_data_keys:
                raise ValueError(f"{module_dir}/module.yml: unsupported keys: {', '.join(sorted(extra))}")

            module_name = module_data.get("name") or module_id.replace("-", " ").title()
            if not isinstance(module_name, str) or not NAME_REGEX.fullmatch(module_name):
                raise ValueError(f"{where_module}.name: invalid name")

            module_description = module_data.get("description")
            module_description_path = module_dir / "DESCRIPTION.md"
            if module_description is None and module_description_path.exists():
                module_description = module_description_path.read_text()
            if module_description is not None and not isinstance(module_description, str):
                raise ValueError(f"{where_module}.description: expected string")

            challenges = module_data.get("challenges")
            if not isinstance(challenges, list) or not challenges:
                raise ValueError(f"{module_dir}/module.yml: expected non-empty 'challenges' list (challenge-only modules)")

            resources = []
            for challenge_index, challenge_entry in enumerate(challenges):
                where_challenge = f"{module_dir}/module.yml.challenges[{challenge_index}]"
                if not isinstance(challenge_entry, dict):
                    raise ValueError(f"{where_challenge}: expected mapping")

                challenge_id = challenge_entry.get("id")
                if not isinstance(challenge_id, str) or not ID_REGEX.fullmatch(challenge_id):
                    raise ValueError(f"{where_challenge}.id: expected /^[a-z0-9-]{{1,32}}$/")

                challenge_dir = module_dir / challenge_id
                challenge_file_path = challenge_dir / "challenge.yml"
                if challenge_file_path.exists():
                    challenge_file_data = yaml.safe_load(challenge_file_path.read_text()) or {}
                    if not isinstance(challenge_file_data, dict):
                        raise ValueError(f"{challenge_file_path}: expected a mapping at the top level")
                else:
                    challenge_file_data = {}

                challenge_data = {**challenge_file_data, **challenge_entry}

                allowed_challenge_keys = {
                    "id",
                    "name",
                    "description",
                    "visibility",
                    "required",
                    "privileged",
                    "allow_privileged",
                    "importable",
                    "progression_locked",
                    "interfaces",
                }
                if extra := set(challenge_data.keys()) - allowed_challenge_keys:
                    raise ValueError(f"{challenge_dir}/challenge.yml: unsupported keys: {', '.join(sorted(extra))}")

                challenge_description_path = challenge_dir / "DESCRIPTION.md"
                if challenge_data.get("description") is None and challenge_description_path.exists():
                    challenge_data["description"] = challenge_description_path.read_text()

                challenge_name = challenge_data.get("name") or challenge_id.replace("-", " ").title()
                if not isinstance(challenge_name, str) or not NAME_REGEX.fullmatch(challenge_name):
                    raise ValueError(f"{where_challenge}.name: invalid name")

                resource = {"type": "challenge", "id": challenge_id, "name": challenge_name}

                if "description" in challenge_data:
                    if not isinstance(challenge_data["description"], str):
                        raise ValueError(f"{where_challenge}.description: expected string")
                    resource["description"] = challenge_data["description"]

                visibility = challenge_data.get("visibility")
                if visibility is not None:
                    if not isinstance(visibility, dict):
                        raise ValueError(f"{where_challenge}.visibility: expected mapping")
                    if extra := set(visibility.keys()) - {"start", "stop"}:
                        raise ValueError(f"{where_challenge}.visibility: unsupported keys: {', '.join(sorted(extra))}")

                    out_visibility = {key: visibility[key] for key in ["start", "stop"] if key in visibility}
                    for key, value in out_visibility.items():
                        if not isinstance(value, str):
                            raise ValueError(f"{where_challenge}.visibility.{key}: expected ISO string")
                        datetime.datetime.fromisoformat(value)
                    resource["visibility"] = out_visibility

                for field in ["privileged", "allow_privileged", "importable", "interfaces"]:
                    if field in challenge_data:
                        value = challenge_data[field]
                    elif field in module_data:
                        value = module_data[field]
                    else:
                        value = dojo_data.get(field)
                    if value is None:
                        continue
                    if field != "interfaces" and not isinstance(value, bool):
                        raise ValueError(f"{where_challenge}.{field}: expected boolean")
                    if field == "interfaces" and not isinstance(value, list):
                        raise ValueError(f"{where_challenge}.interfaces: expected list")
                    resource[field] = value

                if "required" in challenge_data:
                    if not isinstance(challenge_data["required"], bool):
                        raise ValueError(f"{where_challenge}.required: expected boolean")
                    resource["required"] = challenge_data["required"]

                if "progression_locked" in challenge_data:
                    if not isinstance(challenge_data["progression_locked"], bool):
                        raise ValueError(f"{where_challenge}.progression_locked: expected boolean")
                    resource["progression_locked"] = challenge_data["progression_locked"]

                resources.append(resource)

            module_out = {"id": module_id, "name": module_name, "resources": resources}
            if module_description is not None:
                module_out["description"] = module_description
            parsed_modules.append(module_out)

        spec = {"id": dojo_id, "name": dojo_name, "modules": parsed_modules}
        if dojo_type is not None:
            spec["type"] = dojo_type
        if dojo_description is not None:
            spec["description"] = dojo_description
        if dojo_award is not None:
            spec["award"] = dojo_award
    except Exception as error:
        print(f"Error: failed to parse {dojo_yml}: {error}", file=sys.stderr)
        return 1

    print(f"Parsed successfully: dojo={dojo_id}", file=sys.stderr)
    if args.json:
        print(json.dumps(spec, indent=2, sort_keys=False))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
