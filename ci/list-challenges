#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# ///

"""
List challenges in the repository.

By default, all challenges are printed. Use --only-modified to list only the
challenges affected by changes between two commits or refs. When no refs are
supplied, the script compares the current branch against its upstream (or falls
back to main/origin/main).
"""

from __future__ import annotations

import argparse
import os
import pathlib
import subprocess
import sys
from typing import Dict, List, Sequence, Set, Tuple

REPO_ROOT = pathlib.Path(__file__).resolve().parent.parent
CHALLENGES_DIR = REPO_ROOT / "challenges"
CHALLENGES_PREFIX = pathlib.PurePosixPath("challenges")

EMPTY_TREE_SHA = "0000000000000000000000000000000000000000"


def run_git_command(*args: str) -> str:
    result = subprocess.run(
        ["git", *args],
        cwd=REPO_ROOT,
        check=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    return result.stdout.strip()


def determine_commit_range(
    base_arg: str | None,
    head_arg: str | None,
) -> Tuple[str, str | None]:
    if head_arg and not base_arg:
        raise RuntimeError("HEAD reference requires BASE.")
    if base_arg:
        base = base_arg
        head = head_arg  # None means compare with working tree
    else:
        head = "HEAD"
        try:
            upstream = run_git_command(
                "rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"
            )
        except subprocess.CalledProcessError:
            upstream = None

        if upstream:
            base = run_git_command("merge-base", head, upstream)
        else:
            current_branch = run_git_command("rev-parse", "--abbrev-ref", "HEAD")
            base_ref = "origin/main" if current_branch == "main" else "main"
            run_git_command("rev-parse", "--verify", base_ref)
            base = run_git_command("merge-base", head, base_ref)
        head = "HEAD"

    if base == EMPTY_TREE_SHA:
        base = run_git_command("hash-object", "-t", "tree", "/dev/null")
    if head == EMPTY_TREE_SHA:
        head = run_git_command("hash-object", "-t", "tree", "/dev/null")
    return base, head


def list_changed_files(base: str, head: str | None) -> List[pathlib.PurePosixPath]:
    args = ["diff", "--name-only", base]
    if head:
        args.append(head)
    output = run_git_command(*args)
    return [
        pathlib.PurePosixPath(line)
        for line in output.splitlines()
        if line.strip()
    ]


def discover_challenges(root: pathlib.Path) -> Dict[pathlib.PurePosixPath, str]:
    if not root.is_dir():
        raise RuntimeError(f"Challenges directory {root} not found")
    challenges: Dict[pathlib.PurePosixPath, str] = {}
    for dirpath, dirnames, _ in os.walk(root):
        if "challenge" not in dirnames:
            continue
        candidate = pathlib.Path(dirpath)
        relative = candidate.relative_to(root)
        if relative == pathlib.Path("."):
            continue
        rel_posix = relative.as_posix()
        challenge_root = CHALLENGES_PREFIX / rel_posix
        challenges[challenge_root] = rel_posix
    return challenges


def find_challenge_for_path(
    path: pathlib.PurePosixPath, challenges: Dict[pathlib.PurePosixPath, str]
) -> str | None:
    current = path
    while True:
        if current in challenges:
            return challenges[current]
        if current == CHALLENGES_PREFIX or len(current.parts) < 2:
            return None
        current = current.parent


def main(argv: Sequence[str]) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--only-modified",
        dest="only_modified",
        action="store_true",
        help="List only challenges affected by git changes (default lists all).",
    )
    parser.add_argument(
        "base",
        nargs="?",
        help="Git base reference (requires --only-modified).",
    )
    parser.add_argument(
        "head",
        nargs="?",
        help="Git head reference (requires base and --only-modified).",
    )

    try:
        args = parser.parse_args(argv[1:])
        if not args.only_modified and (args.base or args.head):
            parser.error("BASE/HEAD references require --only-modified.")

        challenges = discover_challenges(CHALLENGES_DIR)
        if not args.only_modified:
            for challenge in sorted(challenges.values()):
                print(challenge)
            return 0

        base, head = determine_commit_range(args.base, args.head)
        changed_paths = list_changed_files(base, head)
        if not changed_paths:
            return 0

        affected: Set[str] = set()
        challenge_roots = list(challenges.keys())
        for path in changed_paths:
            if not path.is_relative_to(CHALLENGES_PREFIX):
                continue
            challenge = find_challenge_for_path(path, challenges)
            if challenge:
                affected.add(challenge)
            try:
                common_idx = path.parts.index("common", 1)
            except ValueError:
                continue
            ancestor = pathlib.PurePosixPath(*path.parts[:common_idx])
            for root in challenge_roots:
                if root.is_relative_to(ancestor):
                    affected.add(challenges[root])
        for challenge in sorted(affected):
            print(challenge)
        return 0
    except RuntimeError as exception:
        print(exception, file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv))
