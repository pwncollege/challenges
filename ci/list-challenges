#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# ///

"""
List challenges grouped by git-crypt key.

--modified-since <REF> limits results to challenges affected by changes versus REF (includes staged/unstaged files).
"""

from __future__ import annotations

import argparse
import json
import os
import pathlib
import shlex
import subprocess

repo_root = pathlib.Path(__file__).resolve().parent.parent
challenges_dir = repo_root / "challenges"
prefix = pathlib.PurePosixPath("challenges")

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument("--modified-since", metavar="REF")
parser.add_argument(
    "--format",
    choices=("table", "matrix"),
    default="table",
    help="Output format: table (default) or matrix JSON.",
)
args = parser.parse_args()

challenges = {
    prefix / rel: rel
    for challenge_dir in challenges_dir.glob("**/challenge")
    if (rel := challenge_dir.parent.relative_to(challenges_dir).as_posix()) != "."
}

selected = sorted(challenges.values())
if args.modified_since:
    diff_output = subprocess.check_output(
        ["git", "diff", "--name-only", args.modified_since],
        cwd=repo_root,
        text=True,
    )
    changed = [
        pathlib.PurePosixPath(line) for line in diff_output.splitlines() if line.strip()
    ]
    affected = set()
    roots = list(challenges.keys())
    for path in changed:
        if not path.is_relative_to(prefix):
            continue
        current = path
        challenge = None
        while True:
            if current in challenges:
                challenge = challenges[current]
                break
            if current == prefix or len(current.parts) < 2:
                break
            current = current.parent
        if challenge:
            affected.add(challenge)
            continue
        if "common" in path.parts[1:]:
            ancestor = pathlib.PurePosixPath(*path.parts[: path.parts.index("common", 1)])
            for root in roots:
                if root.is_relative_to(ancestor):
                    affected.add(challenges[root])
    selected = sorted(affected)

group_assignments = {rel: "default" for rel in challenges.values()}
group_patterns = []
for attr_file in sorted(challenges_dir.rglob(".gitattributes")):
    base_rel = (
        attr_file.parent.relative_to(challenges_dir).as_posix()
        if attr_file.parent != challenges_dir
        else ""
    )
    for line in attr_file.read_text().splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        try:
            parts = shlex.split(stripped)
        except ValueError:
            continue
        if len(parts) < 2:
            continue
        pattern, *tokens = parts
        for token in tokens:
            if token.startswith("filter=git-crypt-"):
                group = token.split("=", 1)[1][len("git-crypt-") :]
                combined = f"{base_rel}/{pattern}" if base_rel else pattern
                group_patterns.append((combined, group))

for pattern, group in group_patterns:
    for match in challenges_dir.glob(pattern):
        target = match if match.is_dir() else match.parent
        while target != challenges_dir and target.parent != target:
            rel = target.relative_to(challenges_dir).as_posix()
            if rel in group_assignments:
                if group_assignments[rel] == "default":
                    group_assignments[rel] = group
                break
            target = target.parent

rows = sorted(
    (group_assignments.get(challenge, "default"), challenge) for challenge in selected
)

if args.format == "matrix":
    grouped = {}
    for group, challenge in rows:
        grouped.setdefault(group, []).append(challenge)
    matrix = {
        "group": sorted(grouped),
        "include": [
            {"group": group, "challenges": "\n".join(sorted(challenges))}
            for group, challenges in sorted(grouped.items())
        ],
    }
    if not rows:
        matrix = {"group": [], "include": []}
    print(json.dumps(matrix, separators=(",", ":")))
else:
    group_width = (
        max(len("GROUP"), *(len(group) for group, _ in rows)) if rows else len("GROUP")
    )
    path_width = (
        max(len("PATH"), *(len(path) for _, path in rows)) if rows else len("PATH")
    )
    fmt = f"{{:<{group_width}}}  {{:<{path_width}}}"
    print(fmt.format("GROUP", "PATH"))
    for group, challenge in rows:
        print(fmt.format(group, challenge))
