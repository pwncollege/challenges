#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# ///

"""
Script to detect changed challenges in a git repository.

Usage:
  ./ci/list-changed-challenges [BASE_SHA] [HEAD_SHA]
  ./ci/list-changed-challenges [BASE_SHA]  # compares BASE_SHA with HEAD

If no arguments are provided, the script derives the comparison range from the
GitHub Actions environment or defaults to comparing with main. Output is a
newline-separated list of changed challenge paths (module/challenge format).

Changes under any `common/` directory bubble down to every challenge beneath it.
"""

from __future__ import annotations

import os
import pathlib
import subprocess
import sys
from typing import Dict, Iterable, List, Sequence, Set

REPO_ROOT = pathlib.Path(__file__).resolve().parent.parent
CHALLENGES_DIR = REPO_ROOT / "challenges"
CHALLENGES_PREFIX = pathlib.PurePosixPath("challenges")

EMPTY_TREE_SHA = "0000000000000000000000000000000000000000"
USAGE = (
    "Usage: ./ci/list-changed-challenges [BASE_SHA] [HEAD_SHA]\n"
    "       ./ci/list-changed-challenges [BASE_SHA]\n"
    "\n"
    "If no arguments are provided, the script compares the current branch "
    "against main (or uses GitHub Actions metadata when available)."
)


def run_git_command(*args: str) -> str:
    result = subprocess.run(
        ["git", *args],
        cwd=REPO_ROOT,
        check=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    return result.stdout.strip()


def ensure_ref_exists(ref: str) -> None:
    try:
        run_git_command("rev-parse", "--verify", ref)
    except subprocess.CalledProcessError as exc:
        raise RuntimeError(f"Git reference {ref!r} not found") from exc


def determine_commit_range(args: Sequence[str]) -> tuple[str, str]:
    if len(args) > 2:
        raise RuntimeError(USAGE)
    if len(args) == 2:
        return args[0], args[1]
    if len(args) == 1:
        return args[0], "HEAD"

    event_name = os.environ.get("GITHUB_EVENT_NAME")
    if event_name:
        if event_name == "pull_request":
            base = os.environ.get("GITHUB_BASE_SHA") or os.environ.get(
                "GITHUB_EVENT_PULL_REQUEST_BASE_SHA"
            )
            if not base:
                raise RuntimeError("Could not determine BASE_SHA for pull_request event")
            return base, "HEAD"
        base = os.environ.get("GITHUB_EVENT_BEFORE")
        head = os.environ.get("GITHUB_EVENT_AFTER")
        if not base or not head:
            raise RuntimeError("Push event missing GITHUB_EVENT_BEFORE/AFTER")
        if base == EMPTY_TREE_SHA:
            base = run_git_command("hash-object", "-t", "tree", "/dev/null")
        return base, head

    current_branch = run_git_command("rev-parse", "--abbrev-ref", "HEAD")
    head = "HEAD"
    if current_branch == "main":
        ensure_ref_exists("origin/main")
        return "origin/main", head
    ensure_ref_exists("main")
    return "main", head


def list_changed_files(base: str, head: str) -> List[pathlib.PurePosixPath]:
    output = run_git_command("diff", "--name-only", base, head)
    return [
        pathlib.PurePosixPath(line)
        for line in output.splitlines()
        if line.strip()
    ]


def discover_challenges(root: pathlib.Path) -> Dict[pathlib.PurePosixPath, str]:
    if not root.is_dir():
        raise RuntimeError(f"Challenges directory {root} not found")
    challenges: Dict[pathlib.PurePosixPath, str] = {}
    for dirpath, dirnames, _ in os.walk(root):
        if "challenge" not in dirnames:
            continue
        candidate = pathlib.Path(dirpath)
        relative = candidate.relative_to(root)
        if relative == pathlib.Path("."):
            continue
        rel_posix = relative.as_posix()
        challenge_root = CHALLENGES_PREFIX / rel_posix
        challenges[challenge_root] = rel_posix
    return challenges


def find_challenge_for_path(
    path: pathlib.PurePosixPath, challenges: Dict[pathlib.PurePosixPath, str]
) -> str | None:
    current = path
    while True:
        if current in challenges:
            return challenges[current]
        if current == CHALLENGES_PREFIX or len(current.parts) < 2:
            return None
        current = current.parent


def collect_common_ancestors(
    paths: Iterable[pathlib.PurePosixPath],
) -> Set[pathlib.PurePosixPath]:
    ancestors: Set[pathlib.PurePosixPath] = set()
    for path in paths:
        if not path.is_relative_to(CHALLENGES_PREFIX):
            continue
        parts = path.parts
        try:
            start_idx = parts.index("common", 1)
        except ValueError:
            continue
        ancestors.add(pathlib.PurePosixPath(*parts[:start_idx]))
    return ancestors


def apply_common_changes(
    challenges: Dict[pathlib.PurePosixPath, str],
    ancestors: Set[pathlib.PurePosixPath],
) -> Set[str]:
    affected: Set[str] = set()
    if not ancestors:
        return affected
    challenge_roots = list(challenges.keys())
    for ancestor in ancestors:
        for root in challenge_roots:
            if root.is_relative_to(ancestor):
                affected.add(challenges[root])
    return affected


def main(argv: Sequence[str]) -> int:
    try:
        base, head = determine_commit_range(argv[1:])
        changed_paths = list_changed_files(base, head)
        if not changed_paths:
            return 0
        challenges = discover_challenges(CHALLENGES_DIR)
        affected: Set[str] = set()
        for path in changed_paths:
            if not path.is_relative_to(CHALLENGES_PREFIX):
                continue
            challenge = find_challenge_for_path(path, challenges)
            if challenge:
                affected.add(challenge)
        affected.update(apply_common_changes(challenges, collect_common_ancestors(changed_paths)))
        for challenge in sorted(affected):
            print(challenge)
        return 0
    except RuntimeError as exception:
        print(exception, file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv))
