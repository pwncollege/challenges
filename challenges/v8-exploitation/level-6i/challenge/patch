diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index ea45a7ada6b..f2a3b4c5d6e 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -407,6 +407,38 @@ BUILTIN(ArrayPush) {
   return *isolate->factory()->NewNumberFromUint((new_length));
 }
 
+BUILTIN(ArrayOob) {
+	HandleScope scope(isolate);
+	Handle<Object> receiver = args.receiver();
+	if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast<JSArray>(*receiver))) {
+	  THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+    	isolate->factory()->NewStringFromAsciiChecked("oob: not a simple array")));
+	}
+	Handle<JSArray> array = Cast<JSArray>(receiver);
+	ElementsKind kind = array->GetElementsKind();
+	if (kind != PACKED_DOUBLE_ELEMENTS && kind != HOLEY_DOUBLE_ELEMENTS) {
+	  THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+    	isolate->factory()->NewStringFromAsciiChecked("oob: need double elements")));
+	}
+	Handle<FixedDoubleArray> elements(Cast<FixedDoubleArray>(array->elements()), isolate);
+	uint32_t idx = 0;
+	if (args.length() > 1) {
+		idx = static_cast<uint32_t>(Object::NumberValue(*args.at(1)));
+	}
+	if (args.length() <= 2) {
+		return *(isolate->factory()->NewNumber(elements->get_scalar(idx)));
+	} else {
+		Handle<Object> value = args.at(2);
+		if (!IsNumber(*value)) {
+		  THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+    		isolate->factory()->NewStringFromAsciiChecked("oob: need a number")));
+		}
+		double num = static_cast<double>(Object::NumberValue(*value));
+		elements->set(idx, num);
+		return ReadOnlyRoots(isolate).undefined_value();
+	}
+}
+
 namespace {
 
 V8_WARN_UNUSED_RESULT Tagged<Object> GenericArrayPop(Isolate* isolate,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 78cbf8874ed..c4d5e6f7a8b 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -394,6 +394,7 @@
       ArraySingleArgumentConstructor)                                          \
   TFC(ArrayNArgumentsConstructor, ArrayNArgumentsConstructor)                  \
   CPP(ArrayConcat)                                                             \
+  CPP(ArrayOob)                                                                \
   /* ES6 #sec-array.prototype.fill */                                          \
   CPP(ArrayPrototypeFill)                                                      \
   /* ES7 #sec-array.prototype.includes */                                      \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 9a346d134b9..f7a8b9c0d1e 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1937,6 +1937,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtin::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+	case Builtin::kArrayOob:
+	  return Type::Receiver();
 
     // ArrayBuffer functions.
     case Builtin::kArrayBufferIsView:
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..e5f6a7b8c9d 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <errno.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -107,6 +108,80 @@ namespace {
 
 const int kMB = 1024 * 1024;
 
+// --- DebugPrint Offset Discovery Lab ---
+//
+// This level hides a secret token inside an ArrayBuffer at a randomized
+// offset. The student must use %DebugPrint() with --allow-natives-syntax
+// to inspect object layouts and discover the offset.
+//
+// The token is a 64-bit magic value placed at a random slot in a specially
+// constructed "vault" object. The student must find the token and report it.
+
+static uint64_t g_secret_token = 0;
+static uint32_t g_secret_offset = 0;
+
+void CreateVault(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  // Create an ArrayBuffer with extra padding. Hide a token at a random offset.
+  size_t vault_size = 0x200;  // 512 bytes
+
+  // Generate a pseudo-random offset (multiple of 8, within the buffer)
+  // Use a simple hash of the current timestamp for variety
+  struct timespec ts;
+  clock_gettime(CLOCK_MONOTONIC, &ts);
+  uint32_t seed = static_cast<uint32_t>(ts.tv_nsec ^ ts.tv_sec);
+  // Random offset: 8-byte aligned, range [0x40, 0x180)
+  g_secret_offset = 0x40 + ((seed % 40) * 8);
+  if (g_secret_offset >= vault_size - 8) g_secret_offset = 0x80;
+
+  // Generate random token
+  g_secret_token = ((uint64_t)(seed * 2654435761u) << 32) | (seed ^ 0xDEADC0DE);
+
+  v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(isolate, vault_size);
+  std::shared_ptr<v8::BackingStore> bs = ab->GetBackingStore();
+  uint8_t* data = static_cast<uint8_t*>(bs->Data());
+
+  // Fill with red herrings (plausible-looking values)
+  for (size_t i = 0; i < vault_size; i += 8) {
+    uint64_t herring = 0x4141414141414141ULL + i;
+    memcpy(data + i, &herring, 8);
+  }
+
+  // Place the secret token at the random offset
+  memcpy(data + g_secret_offset, &g_secret_token, 8);
+
+  // Return the ArrayBuffer â€” the student needs to inspect it
+  info.GetReturnValue().Set(ab);
+}
+
+// WinDebugPrint(offset, token_lo, token_hi):
+// Proves the student found both the offset and the token value.
+void WinDebugPrint(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 3 || !info[0]->IsNumber() || !info[1]->IsNumber() || !info[2]->IsNumber()) {
+    isolate->ThrowError("WinDebugPrint(offset, token_lo, token_hi): expected 3 numbers");
+    return;
+  }
+  uint32_t offset = static_cast<uint32_t>(info[0].As<v8::Number>()->Value());
+  uint32_t token_lo = static_cast<uint32_t>(info[1].As<v8::Number>()->Value());
+  uint32_t token_hi = static_cast<uint32_t>(info[2].As<v8::Number>()->Value());
+
+  uint64_t submitted = ((uint64_t)token_hi << 32) | token_lo;
+
+  if (offset != g_secret_offset) {
+    char msg[128];
+    snprintf(msg, sizeof(msg), "WinDebugPrint: wrong offset %u (expected %u)", offset, g_secret_offset);
+    isolate->ThrowError(msg);
+    return;
+  }
+  if (submitted != g_secret_token) {
+    isolate->ThrowError("WinDebugPrint: wrong token value");
+    return;
+  }
+
+  (void)system("/challenge/catflag");
+}
+
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
 // These file descriptors are being opened when Fuzzilli uses fork & execve to
@@ -3364,7 +3431,12 @@ Local<FunctionTemplate> Shell::CreateNodeTemplates(
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "CreateVault",
+                       FunctionTemplate::New(isolate, CreateVault));
+  global_template->Set(isolate, "WinDebugPrint",
+                       FunctionTemplate::New(isolate, WinDebugPrint));
+
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3457,13 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3482,7 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 48249695b7b..99dc014c13c 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -2533,6 +2533,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     SimpleInstallFunction(isolate_, proto, "at", Builtin::kArrayPrototypeAt, 1,
                           true);
+    SimpleInstallFunction(isolate_, proto, "oob",
+                          Builtin::kArrayOob, 0, false);
     SimpleInstallFunction(isolate_, proto, "concat",
                           Builtin::kArrayPrototypeConcat, 1, false);
     SimpleInstallFunction(isolate_, proto, "copyWithin",
