--- a/src/maglev/maglev-graph-builder.cc	2026-02-15 00:25:50.730610148 +0000
+++ b/src/maglev/maglev-graph-builder.cc	2026-02-15 00:44:04.553397125 +0000
@@ -8635,13 +8635,8 @@
       AddNewNode<StoreTaggedFieldNoWriteBarrier>(
           {allocation, GetSmiConstant(value.length)},
           FixedDoubleArray::kLengthOffset);
-      for (int i = 0; i < value.length; ++i) {
-        // TODO(leszeks): Fix hole storage, in case Float64::get_scalar doesn't
-        // preserve custom NaNs.
-        AddNewNode<StoreFloat64>(
-            {allocation, GetFloat64Constant(value.double_values[i])},
-            FixedDoubleArray::OffsetOfElementAt(i));
-      }
+      // BUG: element values are not stored — uninitialized doubles
+      (void)value;
       return allocation;
     }
     case FastFixedArray::kCoW:
--- a/src/d8/d8.cc	2026-02-15 00:25:50.724610153 +0000
+++ b/src/d8/d8.cc	2026-02-15 00:44:42.512308558 +0000
@@ -355,6 +355,46 @@
 v8::Platform* g_default_platform;
 std::unique_ptr<v8::Platform> g_platform;
 
+// ---- maglev-1 challenge helpers ----
+
+static void WinUninitializedField(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !info[0]->IsArray() || !info[1]->IsNumber()) {
+    isolate->ThrowError(
+        "WinUninitializedField(arr, expected_first_element): "
+        "expected array and number");
+    return;
+  }
+
+  v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
+  v8::Local<v8::Array> arr = info[0].As<v8::Array>();
+  double expected = info[1]->NumberValue(ctx).FromJust();
+
+  if (arr->Length() < 2) {
+    isolate->ThrowError(
+        "WinUninitializedField: array needs at least 2 elements");
+    return;
+  }
+
+  v8::Local<v8::Value> elem;
+  if (!arr->Get(ctx, 0).ToLocal(&elem) || !elem->IsNumber()) {
+    isolate->ThrowError(
+        "WinUninitializedField: first element must be a number");
+    return;
+  }
+
+  double actual = elem->NumberValue(ctx).FromJust();
+  if (actual == expected) {
+    isolate->ThrowError(
+        "WinUninitializedField: array element matches expected value — "
+        "no uninitialized memory detected");
+    return;
+  }
+
+  (void)system("/challenge/catflag");
+}
+
 template <int N>
 bool ThrowError(Isolate* isolate, const char (&message)[N]) {
   if (isolate->IsExecutionTerminating()) return false;
@@ -3358,7 +3398,9 @@
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "WinUninitializedField",
+                       FunctionTemplate::New(isolate, WinUninitializedField));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3379,13 +3421,13 @@
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3411,7 +3453,7 @@
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
