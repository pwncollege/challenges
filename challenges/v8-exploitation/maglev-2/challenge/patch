--- a/src/d8/d8.cc	2026-02-15 00:21:17.038742391 +0000
+++ b/src/d8/d8.cc	2026-02-15 01:13:07.981367730 +0000
@@ -355,6 +355,44 @@
 v8::Platform* g_default_platform;
 std::unique_ptr<v8::Platform> g_platform;
 
+// ---- maglev-2 challenge helpers ----
+
+static void WinAllocationFolding(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !info[0]->IsObject() || !info[1]->IsObject()) {
+    isolate->ThrowError(
+        "WinAllocationFolding(obj, innerObj): expected two heap objects");
+    return;
+  }
+
+  auto h0 = Utils::OpenHandle(*info[0]);
+  auto h1 = Utils::OpenHandle(*info[1]);
+  if (!IsHeapObject(*h0) || !IsHeapObject(*h1)) {
+    isolate->ThrowError(
+        "WinAllocationFolding: arguments must be heap objects");
+    return;
+  }
+
+  uint32_t a0 = static_cast<uint32_t>(
+      i::Handle<i::HeapObject>::cast(h0)->address());
+  uint32_t a1 = static_cast<uint32_t>(
+      i::Handle<i::HeapObject>::cast(h1)->address());
+  int32_t diff = static_cast<int32_t>(a1 - a0);
+
+  // If allocation folding spans the super() boundary (CVE-2024-0517 bug),
+  // both objects will be in one folded allocation, adjacent in memory.
+  // Without the bug, they'd be separate allocations with a larger gap.
+  if (diff <= 0 || diff > 256) {
+    isolate->ThrowError(
+        "WinAllocationFolding: objects are not adjacent â€” "
+        "allocation folding not detected across super() boundary");
+    return;
+  }
+
+  (void)system("/challenge/catflag");
+}
+
 template <int N>
 bool ThrowError(Isolate* isolate, const char (&message)[N]) {
   if (isolate->IsExecutionTerminating()) return false;
@@ -3358,7 +3396,9 @@
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "WinAllocationFolding",
+                       FunctionTemplate::New(isolate, WinAllocationFolding));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3379,10 +3419,10 @@
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
-  // Some Emscripten-generated code tries to call 'quit', which in turn would
+/*  // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
   if (!options.omit_quit) {
@@ -3411,7 +3451,7 @@
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
