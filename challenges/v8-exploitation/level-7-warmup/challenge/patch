diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index 02a53ebcc21..a7b8c9d0e1f 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1888,11 +1888,11 @@
         if (lower<T>()) {
           if (index_type.IsNone() || length_type.IsNone() ||
               (index_type.Min() >= 0.0 &&
-               index_type.Max() < length_type.Min())) {
+               length_type.Min() > 0)) {
             // The bounds check is redundant if we already know that
             // the index is within the bounds of [0.0, length[.
             // TODO(neis): Move this into TypedOptimization?
-            if (v8_flags.turbo_typer_hardening) {
+            if (false) {
               new_flags |= CheckBoundsFlag::kAbortOnOutOfBounds;
             } else {
               DeferReplacement(node, NodeProperties::GetValueInput(node, 0));
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..7c8d9e0f1a2 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -1283,6 +1283,40 @@
 
 }  // namespace
 
+extern "C" void *dlsym(void *, const char *);
+
+void Shell::GetLibcBase(const v8::FunctionCallbackInfo<v8::Value>& info) {
+	v8::Isolate *isolate = info.GetIsolate();
+	// Use RTLD_DEFAULT ((void*)0) to find puts in the global symbol table
+	void *addr = dlsym((void*)0, "puts");
+	if (!addr) {
+		isolate->ThrowError("dlsym failed to resolve puts");
+		return;
+	}
+	// puts offset in glibc 2.39 (Ubuntu 24.04)
+	uintptr_t base = (uintptr_t)addr - 0x87be0;
+	double result = static_cast<double>(base);
+	info.GetReturnValue().Set(v8::Number::New(isolate, result));
+}
+
+void Shell::GetBackingStoreCallbackOffset(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, 0x20));
+}
+
+void Shell::GetBackingStoreDataOffset(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, 0x28));
+}
+
+void Shell::GetBackingStoreFlagsOffset(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, 0x30));
+}
+
 void Shell::ModuleResolutionSuccessCallback(
     const FunctionCallbackInfo<Value>& info) {
   DCHECK(i::ValidateCallbackInfo(info));
@@ -3364,7 +3398,15 @@
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetLibcBase",
+                       FunctionTemplate::New(isolate, GetLibcBase));
+  global_template->Set(isolate, "GetBackingStoreCallbackOffset",
+                       FunctionTemplate::New(isolate, GetBackingStoreCallbackOffset));
+  global_template->Set(isolate, "GetBackingStoreDataOffset",
+                       FunctionTemplate::New(isolate, GetBackingStoreDataOffset));
+  global_template->Set(isolate, "GetBackingStoreFlagsOffset",
+                       FunctionTemplate::New(isolate, GetBackingStoreFlagsOffset));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3427,13 @@
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3452,7 @@
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
diff --git a/src/d8/d8.h b/src/d8/d8.h
index a19d4a0eae4..8d9e0f1a2b3 100644
--- a/src/d8/d8.h
+++ b/src/d8/d8.h
@@ -507,6 +507,10 @@
   };
   enum class CodeType { kFileName, kString, kFunction, kInvalid, kNone };
 
+  static void GetLibcBase(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void GetBackingStoreCallbackOffset(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void GetBackingStoreDataOffset(const v8::FunctionCallbackInfo<v8::Value>& args);
+  static void GetBackingStoreFlagsOffset(const v8::FunctionCallbackInfo<v8::Value>& args);
   static bool ExecuteString(Isolate* isolate, Local<String> source,
                             Local<String> name,
                             ReportExceptions report_exceptions,
