diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 050cbdc..c903d20 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3,6 +3,13 @@
 // found in the LICENSE file.
 
 #include <errno.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#ifdef MAP_TYPE
+#undef MAP_TYPE
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -107,6 +109,84 @@ namespace {
 
 const int kMB = 1024 * 1024;
 
+void GetD8Base(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  Dl_info di;
+  if (!dladdr(reinterpret_cast<void*>(&GetD8Base), &di) || !di.dli_fbase) {
+    isolate->ThrowError("dladdr failed");
+    return;
+  }
+  uintptr_t base = reinterpret_cast<uintptr_t>(di.dli_fbase);
+  info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, static_cast<uint64_t>(base)));
+}
+
+void ReadPtr(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !(info[0]->IsNumber() || info[0]->IsBigInt())) {
+    isolate->ThrowError("ReadPtr(addr): expected one number/bigint");
+    return;
+  }
+  bool lossless_addr = true; uint64_t addr = info[0]->IsBigInt() ? info[0].As<v8::BigInt>()->Uint64Value(&lossless_addr) : static_cast<uint64_t>(info[0].As<v8::Number>()->Value()); if (!lossless_addr) { isolate->ThrowError("ReadPtr: addr bigint out of range"); return; }
+  uint64_t val = *reinterpret_cast<uint64_t*>(addr);
+  info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, val));
+}
+
+void WritePtr(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !(info[0]->IsNumber() || info[0]->IsBigInt()) || !(info[1]->IsNumber() || info[1]->IsBigInt())) {
+    isolate->ThrowError("WritePtr(addr, value): expected two numbers/bigints");
+    return;
+  }
+  bool lossless_addr = true; uint64_t addr = info[0]->IsBigInt() ? info[0].As<v8::BigInt>()->Uint64Value(&lossless_addr) : static_cast<uint64_t>(info[0].As<v8::Number>()->Value()); if (!lossless_addr) { isolate->ThrowError("WritePtr: addr bigint out of range"); return; }
+  bool lossless_val = true; uint64_t val = info[1]->IsBigInt() ? info[1].As<v8::BigInt>()->Uint64Value(&lossless_val) : static_cast<uint64_t>(info[1].As<v8::Number>()->Value()); if (!lossless_val) { isolate->ThrowError("WritePtr: value bigint out of range"); return; }
+  // Many modern binaries are built with RELRO, making the GOT read-only after
+  // relocation. Since this is a "bridge" level, allow writing anyway by
+  // temporarily changing the target page to RW.
+  long pagesz = sysconf(_SC_PAGESIZE);
+  if (pagesz <= 0) pagesz = 4096;
+  uintptr_t page = static_cast<uintptr_t>(addr) & ~(static_cast<uintptr_t>(pagesz) - 1);
+  if (mprotect(reinterpret_cast<void*>(page), static_cast<size_t>(pagesz),
+               PROT_READ | PROT_WRITE) != 0) {
+    isolate->ThrowError("WritePtr: mprotect failed");
+    return;
+  }
+  *reinterpret_cast<uint64_t*>(addr) = val;
+}
+
+void DlsymAddr(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsString()) {
+    isolate->ThrowError("DlsymAddr(name): expected one string");
+    return;
+  }
+  v8::String::Utf8Value s(isolate, info[0]);
+  if (*s == nullptr) {
+    isolate->ThrowError("DlsymAddr: utf8 conversion failed");
+    return;
+  }
+  void* addr = dlsym(RTLD_DEFAULT, *s);
+  if (!addr) {
+    isolate->ThrowError("DlsymAddr: dlsym failed");
+    return;
+  }
+  info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(
+      isolate, static_cast<uint64_t>(reinterpret_cast<uintptr_t>(addr))));
+}
+
+void CallPuts(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsString()) {
+    isolate->ThrowError("CallPuts(str): expected one string");
+    return;
+  }
+  v8::String::Utf8Value s(isolate, info[0]);
+  if (*s == nullptr) {
+    isolate->ThrowError("CallPuts: utf8 conversion failed");
+    return;
+  }
+  puts(*s);
+}
+
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
 // These file descriptors are being opened when Fuzzilli uses fork & execve to
@@ -2860,7 +2929,17 @@ Local<FunctionTemplate> Shell::CreateNodeTemplates(Isolate* isolate) {
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetD8Base",
+                       FunctionTemplate::New(isolate, GetD8Base));
+  global_template->Set(isolate, "ReadPtr",
+                       FunctionTemplate::New(isolate, ReadPtr));
+  global_template->Set(isolate, "WritePtr",
+                       FunctionTemplate::New(isolate, WritePtr));
+  global_template->Set(isolate, "DlsymAddr",
+                       FunctionTemplate::New(isolate, DlsymAddr));
+  global_template->Set(isolate, "CallPuts",
+                       FunctionTemplate::New(isolate, CallPuts));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -2877,13 +2956,13 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -2909,7 +2988,7 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::FLAG_expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
