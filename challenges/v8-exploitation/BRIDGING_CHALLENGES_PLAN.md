# V8 Bridging Challenges Plan

## Goal
Add four intermediate challenges that smooth the four RED-rated cliff edges identified in `CAPSTONE_GAP_ANALYSIS.md` while preserving the current phase structure and challenge style.

## Scope and Sequencing
Implement and commit these one at a time, in this exact order:

1. `level-1a` (between `level-1` and `level-1b`)
2. `level-6-warmup` (between `level-6` and `level-6a`)
3. `level-7-warmup` (between `level-7` and `level-7a`)
4. `level-8-warmup` (between `level-8` and `level-8a`)

Each challenge introduces exactly one new conceptual domain and reuses already-learned endgame components so students do not face two new problems simultaneously.

## Challenge Designs

### 1) `level-1a`: V8 Heap Object Layout Warmup

- Gap addressed: `level-1 -> level-1b`
- New concept introduced: V8 heap object internals (ArrayBuffer layout + pointer compression awareness)
- Kept familiar: shellcode endgame (`AllocRWX` + `CallRWX` path)

Design:
- Base from `level-1b` patch patterns.
- Provide `GetAddressOf` + read helper for observing object fields.
- Keep write/execution helpers for solvability after layout discovery.
- Writeup focuses on locating `JSArrayBuffer.backing_store` and verifying offsets before corruption.

Tests:
- Public: d8 sanity (`console.log("ok")`).
- Private: exploit script that first validates discovered object layout values, then pivots backing store and runs `/challenge/catflag`.

Acceptance:
- Students must demonstrate layout reasoning before using the standard pivot.

---

### 2) `level-6-warmup`: JIT Fundamentals Warmup

- Gap addressed: `level-6 -> level-6a`
- New concept introduced: deterministic JIT workflow and map-check assumption failure
- Kept familiar: heap navigation helper (`GetAddressOf`) + standard ROP endgame after OOB

Design:
- Base from `level-6a` patch lineage.
- Keep `--allow-natives-syntax` and helper-assisted heap discovery.
- Simplify target objective to explicitly prove optimization and trigger controlled type confusion before full exploit chain.
- Writeup emphasizes `%PrepareFunctionForOptimization`, `%OptimizeFunctionOnNextCall`, and element-kind mismatch.

Tests:
- Public: d8 sanity.
- Private: scripted exploit that deterministically warms, verifies OOB condition, then reaches flag.

Acceptance:
- Fails if exploit skips JIT warmup stage checks.

---

### 3) `level-7-warmup`: Malloc Heap / BackingStore Primer

- Gap addressed: `level-7 -> level-7a`
- New concept introduced: DataView OOB on malloc heap and BackingStore C++ layout
- Kept familiar: libc helper for endgame (`GetLibcBase`)

Design:
- Base from `level-7a` patch lineage.
- Keep `GetLibcBase` so the only new required skill is malloc-side object identification and deleter corruption mechanics.
- Add stronger writeup guidance for distinguishing V8 heap objects vs malloc-allocated BackingStore objects.

Tests:
- Public: d8 sanity.
- Private: exploit using DataView OOB to find BackingStore-like structures and perform deleter callback overwrite to print flag.

Acceptance:
- Must use BackingStore deleter corruption path (no alternate shortcut).

---

### 4) `level-8-warmup`: Sandbox + WASM Pivot Primer

- Gap addressed: `level-8 -> level-8a`
- New concept introduced: sandbox constraints and WASM `memory_start` pivot
- Kept familiar: helper for base discovery (`Sandbox.getLibcBase`)

Design:
- Base from `level-8a` patch lineage.
- Keep sandbox enabled and MemoryCorruptionApi available.
- Narrow challenge objective to learning the pivot mechanics first, then apply standard final ROP/GOT path.
- Writeup focuses on: why `ArrayBuffer.backing_store` no longer gives raw pointers, and why WASM instance memory pointer remains useful.

Tests:
- Public: d8 sanity.
- Private: exploit that creates WASM instance, pivots `memory_start`, verifies libc ELF read, and triggers `/challenge/catflag`.

Acceptance:
- Must demonstrate a successful memory pivot check before final code execution.

## Module Integration

For each added challenge:
- Add directory tree under `challenges/v8-exploitation/<challenge-id>/`:
  - `challenge/` with `Dockerfile.j2`, `REVISION(.j2)`, `args.gn(.j2|plain)`, `patch`, `run.j2`, `catflag.c.j2`, `.init(.j2)`
  - `tests_public/test_basic.sh`
  - `tests_private/test_exploit.sh`
  - `tests_private/WRITEUP.md`
- Ensure test files are executable.
- Update `challenges/v8-exploitation/module.yml` order so each bridge appears immediately before the cliff-edge level it prepares.

## Commit Plan

1. Commit `BRIDGING_CHALLENGES_PLAN.md` only.
2. For each challenge in order:
   - add challenge files
   - update `module.yml`
   - run `./pwnshop test challenges/v8-exploitation/<challenge-id>`
   - commit only that challenge + module ordering changes needed for that insertion
3. Final sanity run:
   - quick lint/permissions check for executable tests
   - `git status` review

## Risk Notes

- V8 builds are expensive; challenge-by-challenge testing and committing limits rework.
- JIT nondeterminism can make private tests flaky; each exploit test should retry multiple times.
- Existing untracked analysis files remain untouched.
