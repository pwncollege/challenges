diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..a2b3c4d5e6f 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <errno.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -107,6 +108,82 @@ namespace {
 
 const int kMB = 1024 * 1024;
 
+// --- GC Observation Lab helpers ---
+
+// Tracks whether Phase 1 (NewSpace->OldSpace promotion) was proven.
+static std::atomic<bool> g_promotion_proven{false};
+// Tracks whether Phase 2 (WeakRef collection detection) was proven.
+static std::atomic<bool> g_collection_proven{false};
+
+// GetObjectSpaceTag(obj): returns a string indicating the heap space:
+//   "new" if the object is in NewSpace/Young generation
+//   "old" if the object is in OldSpace/Old generation
+//   "unknown" otherwise
+// Students use this BEFORE and AFTER calling gc() to prove an object moved.
+void GetObjectSpaceTag(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsObject()) {
+    isolate->ThrowError("GetObjectSpaceTag(obj): expected one object");
+    return;
+  }
+  i::Tagged<i::Object> obj = *Utils::OpenDirectHandle(*info[0]);
+  if (!IsSmi(obj) && IsHeapObject(obj)) {
+    i::Tagged<i::HeapObject> ho = i::Cast<i::HeapObject>(obj);
+    i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(ho);
+    if (chunk->InYoungGeneration()) {
+      info.GetReturnValue().Set(
+          v8::String::NewFromUtf8Literal(isolate, "new"));
+      return;
+    } else {
+      info.GetReturnValue().Set(
+          v8::String::NewFromUtf8Literal(isolate, "old"));
+      return;
+    }
+  }
+  info.GetReturnValue().Set(
+      v8::String::NewFromUtf8Literal(isolate, "unknown"));
+}
+
+// WinPromotion(before_tag, after_tag): proves NewSpace->OldSpace promotion.
+// Must be called with before_tag="new" and after_tag="old".
+void WinPromotion(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !info[0]->IsString() || !info[1]->IsString()) {
+    isolate->ThrowError("WinPromotion(before, after): expected two strings");
+    return;
+  }
+  v8::String::Utf8Value before(isolate, info[0]);
+  v8::String::Utf8Value after(isolate, info[1]);
+  if (strcmp(*before, "new") == 0 && strcmp(*after, "old") == 0) {
+    g_promotion_proven.store(true, std::memory_order_relaxed);
+    info.GetReturnValue().Set(v8::Boolean::New(isolate, true));
+  } else {
+    isolate->ThrowError("WinPromotion: expected before='new', after='old'");
+  }
+}
+
+// WinCollection(): proves WeakRef-based collection detection.
+// Must be called after g_promotion_proven is true and with evidence that
+// a WeakRef target was collected (deref() returned undefined).
+void WinCollection(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsBoolean()) {
+    isolate->ThrowError("WinCollection(was_undefined): expected one boolean");
+    return;
+  }
+  if (!g_promotion_proven.load(std::memory_order_relaxed)) {
+    isolate->ThrowError("WinCollection: must prove promotion first (call WinPromotion)");
+    return;
+  }
+  bool was_undefined = info[0].As<v8::Boolean>()->Value();
+  if (!was_undefined) {
+    isolate->ThrowError("WinCollection: WeakRef target not yet collected");
+    return;
+  }
+  g_collection_proven.store(true, std::memory_order_relaxed);
+  (void)system("/challenge/catflag");
+}
+
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
 // These file descriptors are being opened when Fuzzilli uses fork & execve to
@@ -3364,7 +3460,16 @@ Local<FunctionTemplate> Shell::CreateNodeTemplates(
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetObjectSpaceTag",
+                       FunctionTemplate::New(isolate, GetObjectSpaceTag));
+  global_template->Set(isolate, "WinPromotion",
+                       FunctionTemplate::New(isolate, WinPromotion));
+  global_template->Set(isolate, "WinCollection",
+                       FunctionTemplate::New(isolate, WinCollection));
+  // gc() is available via --expose-gc flag which d8 enables by default
+  // Students should use gc() to trigger garbage collection
+  // and WeakRef / FinalizationRegistry from the JS standard library.
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3490,13 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3515,7 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
