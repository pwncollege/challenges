diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 050cbdc..9b405c4 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <errno.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -107,6 +108,93 @@ namespace {
 
 const int kMB = 1024 * 1024;
 
+static void DefaultJumpTarget() {}
+static void (*g_jump_slot)() = DefaultJumpTarget;
+
+void GetJumpSlotAddr(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  uintptr_t addr = reinterpret_cast<uintptr_t>(&g_jump_slot);
+  info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, static_cast<uint64_t>(addr)));
+}
+
+void CallJumpSlot(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  (void)info;
+  g_jump_slot();
+}
+
+void WritePtr(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !(info[0]->IsNumber() || info[0]->IsBigInt()) || !(info[1]->IsNumber() || info[1]->IsBigInt())) {
+    isolate->ThrowError("WritePtr(addr, value): expected two numbers/bigints");
+    return;
+  }
+  bool lossless_addr = true; uint64_t addr = info[0]->IsBigInt() ? info[0].As<v8::BigInt>()->Uint64Value(&lossless_addr) : static_cast<uint64_t>(info[0].As<v8::Number>()->Value()); if (!lossless_addr) { isolate->ThrowError("WritePtr: addr bigint out of range"); return; }
+  bool lossless_val = true; uint64_t val = info[1]->IsBigInt() ? info[1].As<v8::BigInt>()->Uint64Value(&lossless_val) : static_cast<uint64_t>(info[1].As<v8::Number>()->Value()); if (!lossless_val) { isolate->ThrowError("WritePtr: value bigint out of range"); return; }
+  *reinterpret_cast<uint64_t*>(addr) = val;
+}
+
+void AllocRWX(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsNumber()) {
+    isolate->ThrowError("AllocRWX(size): expected one number");
+    return;
+  }
+  size_t sz = static_cast<size_t>(info[0].As<v8::Number>()->Value());
+  if (sz == 0 || sz > 0x100000) {
+    isolate->ThrowError("AllocRWX: unreasonable size");
+    return;
+  }
+  void* mem = mmap(nullptr, sz, PROT_READ | PROT_WRITE | PROT_EXEC,
+                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (mem == MAP_FAILED) {
+    isolate->ThrowError("AllocRWX: mmap failed");
+    return;
+  }
+  info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(
+      isolate, static_cast<uint64_t>(reinterpret_cast<uintptr_t>(mem))));
+}
+
+void WriteBytes(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 2 || !(info[0]->IsNumber() || info[0]->IsBigInt()) || !info[1]->IsUint8Array()) {
+    isolate->ThrowError("WriteBytes(addr, u8array): expected (number/bigint, Uint8Array)");
+    return;
+  }
+  bool lossless_addr = true; uint64_t addr = info[0]->IsBigInt() ? info[0].As<v8::BigInt>()->Uint64Value(&lossless_addr) : static_cast<uint64_t>(info[0].As<v8::Number>()->Value()); if (!lossless_addr) { isolate->ThrowError("WriteBytes: addr bigint out of range"); return; }
+  v8::Local<v8::Uint8Array> u8 = info[1].As<v8::Uint8Array>();
+  v8::Local<v8::ArrayBuffer> ab = u8->Buffer();
+  size_t offset = u8->ByteOffset();
+  size_t len = u8->ByteLength();
+  std::shared_ptr<v8::BackingStore> bs = ab->GetBackingStore();
+  const uint8_t* src = static_cast<const uint8_t*>(bs->Data()) + offset;
+  memcpy(reinterpret_cast<void*>(addr), src, len);
+}
+
+static bool IsExecutableAddr(uint64_t addr) {
+  std::ifstream f("/proc/self/maps");
+  if (!f.good()) return false;
+  std::string line;
+  while (std::getline(f, line)) {
+    uint64_t start = 0, end = 0;
+    char perms[5] = {0};
+    if (sscanf(line.c_str(), "%lx-%lx %4s", &start, &end, perms) != 3) continue;
+    if (addr < start || addr >= end) continue;
+    return perms[2] == 'x';
+  }
+  return false;
+}
+
+void IsExecutable(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !(info[0]->IsNumber() || info[0]->IsBigInt())) {
+    isolate->ThrowError("IsExecutable(addr): expected one number/bigint");
+    return;
+  }
+  bool lossless_addr = true; uint64_t addr = info[0]->IsBigInt() ? info[0].As<v8::BigInt>()->Uint64Value(&lossless_addr) : static_cast<uint64_t>(info[0].As<v8::Number>()->Value()); if (!lossless_addr) { isolate->ThrowError("IsExecutable: addr bigint out of range"); return; }
+  bool ok = IsExecutableAddr(addr);
+  info.GetReturnValue().Set(v8::Boolean::New(isolate, ok));
+}
+
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
 // These file descriptors are being opened when Fuzzilli uses fork & execve to
@@ -2860,7 +2948,14 @@ Local<FunctionTemplate> Shell::CreateNodeTemplates(Isolate* isolate) {
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "AllocRWX", FunctionTemplate::New(isolate, AllocRWX));
+  global_template->Set(isolate, "WriteBytes", FunctionTemplate::New(isolate, WriteBytes));
+  global_template->Set(isolate, "IsExecutable", FunctionTemplate::New(isolate, IsExecutable));
+  global_template->Set(isolate, "GetJumpSlotAddr",
+                       FunctionTemplate::New(isolate, GetJumpSlotAddr));
+  global_template->Set(isolate, "WritePtr", FunctionTemplate::New(isolate, WritePtr));
+  global_template->Set(isolate, "CallJumpSlot", FunctionTemplate::New(isolate, CallJumpSlot));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -2877,13 +2972,13 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -2909,7 +3004,7 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::FLAG_expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
