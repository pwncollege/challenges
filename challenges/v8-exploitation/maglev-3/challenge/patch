--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -355,6 +355,99 @@
 v8::Platform* g_default_platform;
 std::unique_ptr<v8::Platform> g_platform;

+// ---- maglev-3 challenge helpers ----
+
+static void GetAddressOf(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() == 0) {
+    isolate->ThrowError("GetAddressOf(obj): expected one heap object");
+    return;
+  }
+  auto h = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*h)) {
+    isolate->ThrowError("GetAddressOf: argument must be a heap object");
+    return;
+  }
+  uint32_t addr = static_cast<uint32_t>(
+      i::Handle<i::HeapObject>::cast(h)->address());
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, addr));
+}
+
+static void WinOOBWrite(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+
+  if (info.Length() < 3 || !info[0]->IsObject() ||
+      !info[1]->IsNumber() || !info[2]->IsNumber()) {
+    isolate->ThrowError(
+        "WinOOBWrite(instance, before_gc_addr, after_gc_addr): "
+        "expected object and two addresses");
+    return;
+  }
+
+  uint32_t before_addr = info[1]->Uint32Value(context).FromJust();
+  uint32_t after_addr = info[2]->Uint32Value(context).FromJust();
+
+  if (before_addr == 0 || after_addr == 0) {
+    isolate->ThrowError("WinOOBWrite: addresses must be nonzero");
+    return;
+  }
+
+  if (before_addr == after_addr) {
+    isolate->ThrowError(
+        "WinOOBWrite: instance was not moved by GC "
+        "(before_gc_addr == after_gc_addr)");
+    return;
+  }
+
+  // Get instance address
+  auto inst_handle = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*inst_handle)) {
+    isolate->ThrowError("WinOOBWrite: instance must be a heap object");
+    return;
+  }
+  uint32_t inst_addr = static_cast<uint32_t>(
+      i::Handle<i::HeapObject>::cast(inst_handle)->address());
+
+  // Verify after_gc_addr matches current instance address
+  if (inst_addr != after_addr) {
+    isolate->ThrowError(
+        "WinOOBWrite: after_gc_addr does not match current instance address");
+    return;
+  }
+
+  // Get inst.a (the folded array)
+  v8::Local<v8::Object> inst = info[0].As<v8::Object>();
+  v8::Local<v8::Value> a_val;
+  if (!inst->Get(context, v8::String::NewFromUtf8Literal(isolate, "a"))
+           .ToLocal(&a_val) || !a_val->IsObject()) {
+    isolate->ThrowError(
+        "WinOOBWrite: instance must have property 'a' (the folded array)");
+    return;
+  }
+  auto a_handle = Utils::OpenHandle(*a_val);
+  if (!IsHeapObject(*a_handle)) {
+    isolate->ThrowError("WinOOBWrite: inst.a must be a heap object");
+    return;
+  }
+  uint32_t a_addr = static_cast<uint32_t>(
+      i::Handle<i::HeapObject>::cast(a_handle)->address());
+
+  // Folding preserved: a should be within 128 bytes of inst
+  int32_t diff = static_cast<int32_t>(a_addr - inst_addr);
+  if (diff <= 0 || diff > 128) {
+    isolate->ThrowError(
+        "WinOOBWrite: allocation folding not preserved after GC "
+        "(inst.a is too far from instance)");
+    return;
+  }
+
+  (void)system("/challenge/catflag");
+}
+
 template <int N>
 bool ThrowError(Isolate* isolate, const char (&message)[N]) {
   if (isolate->IsExecutionTerminating()) return false;
@@ -3358,7 +3451,11 @@

 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetAddressOf",
+                       FunctionTemplate::New(isolate, GetAddressOf));
+  global_template->Set(isolate, "WinOOBWrite",
+                       FunctionTemplate::New(isolate, WinOOBWrite));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3379,10 +3476,10 @@
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
-  // Some Emscripten-generated code tries to call 'quit', which in turn would
+/*  // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
   if (!options.omit_quit) {
@@ -3411,7 +3508,7 @@
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/

   return global_template;
 }
