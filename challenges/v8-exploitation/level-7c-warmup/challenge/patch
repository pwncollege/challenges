diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 050cbdc..01132cf 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -8,6 +8,7 @@
 #include <sys/stat.h>
 
 #include <algorithm>
+#include <atomic>
 #include <fstream>
 #include <iomanip>
 #include <iterator>
@@ -107,6 +108,45 @@ namespace {
 
 const int kMB = 1024 * 1024;
 
+static std::atomic<bool> g_collected{false};
+static v8::Global<v8::Object>* g_weak = nullptr;
+
+void WeakCallback(const v8::WeakCallbackInfo<std::atomic<bool>>& data) {
+  data.GetParameter()->store(true, std::memory_order_relaxed);
+  if (g_weak) g_weak->Reset();
+}
+
+void RegisterWeak(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (info.Length() != 1 || !info[0]->IsObject()) {
+    isolate->ThrowError("RegisterWeak(obj): expected one object argument");
+    return;
+  }
+  g_collected.store(false, std::memory_order_relaxed);
+  if (!g_weak) g_weak = new v8::Global<v8::Object>(); g_weak->Reset(isolate, info[0].As<v8::Object>());
+  g_weak->SetWeak(&g_collected, WeakCallback, v8::WeakCallbackType::kParameter);
+}
+
+void WasCollected(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  bool v = g_collected.load(std::memory_order_relaxed) || (g_weak && g_weak->IsEmpty());
+  info.GetReturnValue().Set(v8::Boolean::New(isolate, v));
+}
+
+[[maybe_unused]] void GarbageCollect(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  info.GetIsolate()->RequestGarbageCollectionForTesting(
+      v8::Isolate::kFullGarbageCollection);
+}
+
+void WinAsyncGC(const v8::FunctionCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  if (!g_collected.load(std::memory_order_relaxed)) {
+    isolate->ThrowError("WinAsyncGC: collection not observed");
+    return;
+  }
+  (void)system("/challenge/catflag");
+}
+
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
 // These file descriptors are being opened when Fuzzilli uses fork & execve to
@@ -2860,7 +2900,14 @@ Local<FunctionTemplate> Shell::CreateNodeTemplates(Isolate* isolate) {
 
 Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local<ObjectTemplate> global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  // Do not override the built-in `gc()` provided by d8 via `--expose-gc`.
+  global_template->Set(isolate, "RegisterWeak",
+                       FunctionTemplate::New(isolate, RegisterWeak));
+  global_template->Set(isolate, "WasCollected",
+                       FunctionTemplate::New(isolate, WasCollected));
+  global_template->Set(isolate, "WinAsyncGC",
+                       FunctionTemplate::New(isolate, WinAsyncGC));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -2877,13 +2924,13 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -2909,7 +2956,7 @@ Local<ObjectTemplate> Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::FLAG_expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
 
   return global_template;
 }
