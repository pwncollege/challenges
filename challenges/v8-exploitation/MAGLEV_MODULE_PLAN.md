# Maglev Exploitation Submodule Plan

## Overview

This document plans a new section of the V8 exploitation module focused on **Maglev**, V8's mid-tier optimizing JIT compiler. Maglev sits between Sparkplug (baseline) and TurboFan (top-tier) in the compilation pipeline and has been the source of multiple high-severity CVEs since 2023, including an in-the-wild 0-day exploited by Lazarus Group (CVE-2024-4947).

The existing curriculum covers TurboFan/Turboshaft JIT bugs extensively but has zero Maglev content. This submodule fills that gap.

---

## V8 Revision

All challenges use a single V8 revision: **`f5e412a1cd82fb606b79a587f1c4bda7f9445701`** (same as levels 7e–9d and the educational CVE challenges). This avoids introducing a third build epoch.

Maglev is present and functional in this revision. Each challenge introduces its vulnerability and helpers via a patch applied to this baseline. The CVE-real variants will use the original vulnerable V8 commits.

---

## Placement in Module

The Maglev section appears as a new header block in `module.yml`, positioned **after "JIT Bugs on the V8 Heap"** (levels 6-warmup through cve-2020-6418) and **before "Garbage Collection Internals"** (level-6f-warmup). This is the natural location because:

1. Students already understand JIT compilation, element-kind confusion, and type feedback from the TurboFan section
2. Maglev bugs share conceptual DNA with TurboFan bugs (type confusion, optimization assumptions) but have distinct mechanisms
3. The GC and malloc-heap sections that follow are independent of which compiler tier was used

```yaml
# Proposed module.yml placement:

- type: header
  content: JIT Bugs on the V8 Heap
  # ... existing levels 6-warmup through cve-2020-6418-real ...

- type: header
  content: Maglev Compiler Exploitation    # <-- NEW SECTION
  # ... new challenges ...

- type: header
  content: Garbage Collection Internals
  # ... existing levels 6f-warmup through 6h ...
```

---

## Challenge Progression (7 Challenges)

### Ramp Architecture

The submodule follows the same pedagogical pattern as the existing TurboFan section: observation warmup → isolated proof labs → guided CVE bridge → full CVE → CVE on real V8.

```
                                    Difficulty
                                        │
  maglev-warmup ●────────────────────── │ Observe Maglev compilation, contrast with TurboFan
                                        │
  maglev-1      ●●●──────────────────── │ Reflect.construct + uninitialized fields (guided)
                                        │
  maglev-2      ●●●●●────────────────── │ Allocation folding proof lab
                                        │
  maglev-3      ●●●●●●●──────────────── │ CVE-2024-0517 bridge: GC-triggered OOB write
                                        │
  cve-2024-0517 ●●●●●●●●●────────────── │ Full CVE exploitation (educational V8)
                                        │
  cve-2024-0517-real ●●●●●●●●●●──────── │ Full CVE exploitation (original vulnerable V8)
                                        │
  cve-2024-4947 ●●●●●●●●●●●●────────── │ Module namespace type confusion (Lazarus ITW 0-day)
                                        │
```

### Prerequisites

Students entering this section should have completed:
- levels 6-warmup through 6c (JIT element-kind confusion, OOB from JIT)
- level-7e (Reflect.construct + Proxy side-effect mechanics)

These provide the foundational understanding of JIT type feedback, speculative optimization, deoptimization, and the Reflect.construct trigger pattern that Maglev challenges build on.

---

## Challenge Designs

### Challenge 1: `maglev-warmup` — Maglev Compilation Observation Lab

**Section role:** Observation warmup (no exploitation)

**Concept:** Students learn to trigger, observe, and contrast Maglev compilation with TurboFan. This is purely an observation/proof challenge — students don't need to exploit anything, just demonstrate understanding of the Maglev compilation tier.

**What the patch provides:**
- A `WinMaglevObserved(maglev_status, turbofan_status)` win-condition helper
- The helper validates that the student passed correct `%GetOptimizationStatus()` values proving a function was compiled by Maglev (not TurboFan or Sparkplug)
- No vulnerability is introduced; this is a learning exercise

**What students learn:**
1. V8's multi-tier compilation pipeline: Ignition → Sparkplug → Maglev → TurboFan
2. How to use `%OptimizeMaglevOnNextCall(fn)` to force Maglev compilation
3. How to read `%GetOptimizationStatus(fn)` bit flags to distinguish Maglev from TurboFan
4. How Maglev's CFG-based SSA differs from TurboFan's sea-of-nodes (conceptual, observed via optimization behavior)
5. Maglev compiles faster but produces less optimized code — students can observe this via execution timing or optimization status progression

**Win condition:** Call `WinMaglevObserved(status_after_maglev, status_after_turbofan)` where:
- `status_after_maglev` shows Maglev-optimized state
- `status_after_turbofan` shows TurboFan-optimized state (proving the student triggered both tiers)

**Solve outline:**
```javascript
function target(x) { return x + 1; }
%PrepareFunctionForOptimization(target);
target(1); target(2);
%OptimizeMaglevOnNextCall(target);
target(3);
let maglev_status = %GetOptimizationStatus(target);
%OptimizeFunctionOnNextCall(target);
target(4);
let turbofan_status = %GetOptimizationStatus(target);
WinMaglevObserved(maglev_status, turbofan_status);
```

**Difficulty:** 2/10 — pure observation, no exploitation

---

### Challenge 2: `maglev-1` — Incomplete Object Initialization (Guided)

**Section role:** Bridge challenge (isolated vulnerability with helpers)

**Concept:** Exploit Maglev's `BuildAllocateFastObject` to create an object with uninitialized fields via a `Reflect.construct` new.target mismatch. This is the core mechanism behind CVE-2023-4069 but simplified with helpers.

**What the patch provides:**
- **Vulnerability:** Modifies `maglev-graph-builder.cc` in `TryBuildFindNonDefaultConstructorOrConstruct` to skip the constructor field validation check. When `Reflect.construct(B, [], X)` is called with a mismatched `X` (e.g., Array), Maglev allocates an object using X's initial_map without verifying that X's constructor matches the actual target.
- **Helpers:**
  - `GetAddressOf(obj)` — returns heap address
  - `WinUninitializedField(arr)` — validates that an Array has uninitialized length (length > 0x1000 when only small arrays were allocated), calls catflag

**What students learn:**
1. How Maglev handles constructor calls and `new.target`
2. The relationship between `initial_map`, constructor fields, and object layout
3. How `Reflect.construct` with a mismatched `new.target` creates type confusion
4. How uninitialized memory in heap-allocated objects leads to exploitable conditions
5. The difference between Maglev's eager object materialization vs. TurboFan's approach

**Vulnerability type:** Incomplete object initialization → uninitialized array length → OOB

**Win condition:** Create an Array whose length field reads as a large value (because it was never properly initialized), then pass it to `WinUninitializedField(arr)`.

**Solve outline:**
1. Define a constructor `B` and a proxy/alternative constructor `X` whose `initial_map` describes an Array-like layout
2. Warm up `Reflect.construct(B, [], X)` pattern under Maglev
3. After Maglev optimization, the allocated object has uninitialized fields
4. The uninitialized length field takes whatever value was previously in that heap slot
5. Spray the heap to influence the uninitialized value
6. Pass the resulting "large length" array to the win helper

**Difficulty:** 4/10 — guided with helpers; students focus on the trigger mechanics

---

### Challenge 3: `maglev-2` — Allocation Folding Proof Lab

**Section role:** Proof-of-concept lab (isolated vulnerability concept)

**Concept:** Demonstrate Maglev's allocation folding optimization and prove that folded allocations can span a GC boundary. This isolates the core mechanism of CVE-2024-0517 without requiring a full exploit chain.

**What the patch provides:**
- **Vulnerability:** Modifies `maglev-graph-builder.cc` so that `BuildAllocateFastObject` (called during `TryBuildFindNonDefaultConstructorOrConstruct`) does not clear `current_raw_allocation_`. A subsequent allocation (e.g., creating a double array literal) gets folded with the previous one via `ExtendOrReallocateCurrentRawAllocation`. If GC occurs between the two folded allocations, the second write targets stale/relocated memory.
- **Helper:**
  - `WinAllocationFolding(before_gc_value, after_gc_value)` — validates that two reads of the same array element yield different values (proving the backing memory was relocated by GC but the folded allocation wrote to the old location)

**What students learn:**
1. What allocation folding is and why V8 uses it (performance: combine multiple small allocations into one larger bump-pointer allocation)
2. How `current_raw_allocation_` tracks the allocation frontier
3. Why failing to clear `current_raw_allocation_` after certain operations creates a dangling folding anchor
4. How GC invalidates folded allocation assumptions (object relocation moves the first allocation, but the offset for the second allocation still points to the old location)
5. The concept of a "GC window" between two folded allocations

**Vulnerability type:** Stale allocation folding across GC → OOB write to freed/relocated memory

**Win condition:** Demonstrate that a value written via folded allocation lands in unexpected memory after GC, by showing before/after value divergence.

**Solve outline:**
1. Construct a function that triggers `BuildAllocateFastObject` followed by a double array literal (both get allocation-folded)
2. Warm up under Maglev
3. On the optimized call, force GC (via `gc()` or allocation pressure) between the two "folded" allocations
4. Read the double array — its values reflect the stale offset (pointing to relocated/freed memory rather than the expected location)
5. Pass the before-GC and after-GC readings to `WinAllocationFolding`

**Difficulty:** 5/10 — proof lab with helper; the tricky part is understanding the GC timing, but no full exploit chain required

---

### Challenge 4: `maglev-3` — GC-Triggered OOB Write via Allocation Folding (Bridge)

**Section role:** CVE bridge (one step before full CVE-2024-0517)

**Concept:** Extend the allocation folding concept from maglev-2 into an actual OOB write primitive. Students must weaponize the stale folded allocation into a controlled OOB write that corrupts an adjacent object. Still provides helpers for the endgame.

**What the patch provides:**
- **Vulnerability:** Same allocation folding bug as maglev-2 (no `current_raw_allocation_` clearance)
- **Helpers:**
  - `GetAddressOf(obj)` — returns heap address
  - No win-condition helper — students must use the OOB write to corrupt a victim array's length and then call `/challenge/catflag` via a full primitive chain

**What students learn:**
1. How to convert a stale-offset OOB write into a controlled corruption target
2. Heap layout manipulation: spraying objects so the OOB write hits a victim array's metadata (length or map field)
3. Building addrof/fakeobj primitives from a length-corrupted OOB array
4. The distinction between Young Space (where Maglev-allocated objects start) and Old Space (where GC-promoted objects are stable)
5. Constructing GC-resistant primitives by promoting objects to Old Space before weaponizing

**Vulnerability type:** Allocation folding OOB write → array length corruption → addrof/fakeobj → ROP or WASM RWX

**Solve outline:**
1. Set up heap layout: allocate victim double array adjacent to the folded allocation target
2. Trigger Maglev-compiled function with GC during the folding window
3. The OOB write corrupts victim array's length field
4. Use corrupted array for OOB reads to build addrof primitive
5. Use addrof to locate WASM instance or other targets
6. Build arbitrary R/W and achieve code execution

**Difficulty:** 7/10 — full primitive chain required but with `GetAddressOf` helper

---

### Challenge 5: `cve-2024-0517` — Maglev Allocation Folding OOB (Educational)

**Section role:** Full CVE exploitation (educational V8 revision)

**Concept:** Exploit CVE-2024-0517 end-to-end on the shared educational V8 revision (`f5e412a1`). No helpers provided beyond the vulnerability itself. Students must independently build the full chain: trigger bug → OOB write → primitive construction → code execution.

**What the patch provides:**
- **Vulnerability only:** Same allocation folding bug. The patch modifies `maglev-graph-builder.cc` to skip clearing `current_raw_allocation_` after `TryBuildFindNonDefaultConstructorOrConstruct`.
- **No helpers.** Students must discover addresses, build primitives, and achieve code execution entirely on their own.

**What students learn:**
1. Full end-to-end Maglev exploitation without scaffolding
2. Reliable heap grooming for controlled OOB target placement
3. Multiple endgame strategies:
   - WASM RWX: locate WASM instance object, read RWX code page pointer, overwrite with shellcode
   - JIT spray: encode shellcode as IEEE 754 doubles in function constants, redirect JIT code entry
   - GOT overwrite: locate d8 GOT, overwrite `free`/`puts` with `system`
4. Exploit reliability: handling GC non-determinism, using retries, promoting objects to Old Space

**Vulnerability type:** CVE-2024-0517 — Maglev allocation folding OOB write

**Solve outline:**
1. Trigger allocation folding bug under Maglev with GC in folding window
2. Corrupt adjacent object metadata for OOB primitive
3. Build addrof via type confusion (double array vs object array overlap)
4. Locate WASM RWX page or d8 GOT
5. Write shellcode or overwrite GOT entry
6. Execute `/challenge/catflag`

**Difficulty:** 9/10 — no helpers, full chain, GC timing challenges

---

### Challenge 6: `cve-2024-0517-real` — Maglev Allocation Folding OOB (Original V8)

**Section role:** Real CVE on original vulnerable V8 revision

**Concept:** Same vulnerability as cve-2024-0517 but on the **original vulnerable V8 commit** (pre-patch Chrome ~119/120). All heap offsets, object layouts, map values, and memory layout differ from the educational version. Students must adapt their exploit to a completely different binary.

**V8 revision:** The original vulnerable V8 commit, identified from the [Chromium patch CL 5173470](https://chromium-review.googlesource.com/c/v8/v8/+/5173470). The REVISION file will contain the parent commit of the fix.

**What the patch provides:**
- **Minimal patch:** Only the safety sandbox (commenting out dangerous d8 functions like `quit`, `load`, etc.). The vulnerability exists natively in this V8 version — no need to inject it.

**What students learn:**
1. Adapting exploits across V8 versions — different map values, field offsets, element backing store layouts
2. Dynamic offset discovery using `%DebugPrint()` (skill from level-6i)
3. Understanding how V8 internals change between versions

**Difficulty:** 10/10 — different binary, no helpers, must rediscover all offsets

---

### Challenge 7: `cve-2024-4947` — Module Namespace AccessInfo Type Confusion (Lazarus ITW)

**Section role:** Advanced capstone (real-world 0-day)

**Concept:** Exploit CVE-2024-4947, the Maglev type confusion bug exploited in the wild by the Lazarus Group. This is architecturally different from the allocation folding bugs — it targets Maglev's property access compilation for module namespace objects.

**V8 revision:** The original vulnerable V8 commit (pre-patch Chrome ~124/125, from [Chromium issue 340221135](https://issues.chromium.org/issues/340221135)). Uses its own REVISION file with the original vulnerable commit.

**What the patch provides:**
- **Minimal patch:** Only the safety sandbox. The vulnerability exists natively: `PropertyAccessInfo::ModuleExport()` returns `kModuleExport` kind with "none" field representation and field index offset 0, causing Maglev to write to the wrong location (the FixedArray map field instead of the property slot).

**What students learn:**
1. A fundamentally different Maglev bug class: property access compilation errors (vs. allocation folding)
2. How V8's `PropertyAccessInfo` system works and how module namespace objects are special
3. The GC-based type confusion chain: corrupt PropertyArray map → GC misinterprets object size → truncation → OOB to adjacent objects
4. How state-sponsored actors exploit browser vulnerabilities (Lazarus Group's "DeTankZone" campaign context)
5. The difference between corrupting object maps vs. corrupting object data

**Vulnerability type:** CVE-2024-4947 — Maglev module namespace AccessInfo type confusion → PropertyArray map corruption → GC truncation → OOB

**Solve outline:**
1. Create a module that exports a mutable binding
2. In a separate script, access the module namespace property under Maglev optimization
3. Maglev's compiled code writes to offset 0 of the PropertyArray (the map field) instead of the property slot
4. The corrupted map makes GC treat the PropertyArray as a SeqTwoByteString with wrong size
5. GC evacuates with truncated size, creating OOB to adjacent heap objects
6. Build primitives from the OOB access
7. Achieve code execution

**Difficulty:** 10/10 — different vulnerability class from all prior challenges, requires deep understanding of V8 property access internals and GC object representation

---

## Summary Table

| Challenge | Type | Vulnerability Class | Helpers | Difficulty | Key Learning |
|-----------|------|-------------------|---------|------------|--------------|
| maglev-warmup | Observation lab | None (no vuln) | `WinMaglevObserved` | 2/10 | Maglev compilation pipeline, optimization status flags |
| maglev-1 | Bridge | Incomplete object init | `GetAddressOf`, `WinUninitializedField` | 4/10 | Reflect.construct new.target mismatch in Maglev |
| maglev-2 | Proof lab | Allocation folding | `WinAllocationFolding` | 5/10 | Allocation folding internals, GC interaction |
| maglev-3 | CVE bridge | Allocation folding OOB | `GetAddressOf` | 7/10 | Full OOB→primitives chain from folding bug |
| cve-2024-0517 | Full CVE | Allocation folding OOB | None | 9/10 | End-to-end Maglev exploitation |
| cve-2024-0517-real | Real CVE | Allocation folding OOB | None | 10/10 | Offset adaptation, real vulnerable binary |
| cve-2024-4947 | Capstone | AccessInfo type confusion | None | 10/10 | Different Maglev bug class, GC-based type confusion, ITW 0-day |

---

## Dependency Graph

```
                 ┌─────────────────────────────────────────┐
                 │  Prerequisites (existing curriculum):   │
                 │  levels 6-warmup through 6c (JIT basics)│
                 │  level-7e (Reflect.construct + Proxy)   │
                 └──────────────┬──────────────────────────┘
                                │
                   ┌────────────▼────────────┐
                   │     maglev-warmup       │
                   │  (observe compilation)  │
                   └────────────┬────────────┘
                                │
                   ┌────────────▼────────────┐
                   │       maglev-1          │
                   │  (uninitialized fields) │
                   └────────────┬────────────┘
                                │
                   ┌────────────▼────────────┐
                   │       maglev-2          │
                   │  (folding proof lab)    │
                   └────────────┬────────────┘
                                │
                   ┌────────────▼────────────┐
                   │       maglev-3          │
                   │  (folding OOB bridge)   │
                   └────────────┬────────────┘
                                │
                   ┌────────────▼────────────┐
                   │    cve-2024-0517        │
                   │  (full CVE, edu V8)     │
                   └────────────┬────────────┘
                                │
               ┌────────────────┼────────────────┐
               │                                 │
  ┌────────────▼────────────┐       ┌────────────▼────────────┐
  │   cve-2024-0517-real    │       │    cve-2024-4947        │
  │  (original vuln V8)     │       │  (different bug class,  │
  │                         │       │   Lazarus ITW 0-day)    │
  └─────────────────────────┘       └─────────────────────────┘
```

`cve-2024-0517-real` and `cve-2024-4947` are independent of each other but both require mastery of the allocation folding chain. `cve-2024-4947` introduces an entirely different Maglev bug class as a capstone.

---

## Module.yml Entries

```yaml
- type: header
  content: Maglev Compiler Exploitation

- id: maglev-warmup
  name: "Maglev Warmup: Compilation Observation Lab"
  type: challenge
  description: "Observe Maglev's compilation tier: trigger Maglev and TurboFan independently, read optimization status flags, and contrast the two JIT compilers."

- id: maglev-1
  name: "Maglev 1: Incomplete Object Initialization"
  type: challenge
  description: "Exploit Maglev's BuildAllocateFastObject with a Reflect.construct new.target mismatch to create an object with uninitialized fields."

- id: maglev-2
  name: "Maglev 2: Allocation Folding Proof Lab"
  type: challenge
  description: "Prove that Maglev's allocation folding can span a GC boundary: demonstrate before/after value divergence when folded allocations are relocated."

- id: maglev-3
  name: "Maglev 3: GC-Triggered OOB via Allocation Folding"
  type: challenge
  description: "Bridge before CVE-2024-0517: weaponize the allocation folding stale offset into a controlled OOB write and build exploit primitives."

- id: cve-2024-0517
  name: cve-2024-0517
  type: challenge
  description: "CVE-2024-0517: Maglev allocation folding OOB write. Exploit the uncleared current_raw_allocation_ pointer across a GC boundary."

- id: cve-2024-0517-real
  name: cve-2024-0517-real
  type: challenge
  description: "CVE-2024-0517 on the original vulnerable V8 version. All offsets are different!"

- id: cve-2024-4947
  name: cve-2024-4947
  type: challenge
  description: "CVE-2024-4947: Maglev module namespace AccessInfo type confusion. A real 0-day exploited in the wild by the Lazarus Group!"
```

---

## Risks and Open Questions

### V8 Revision Compatibility

The plan specifies `f5e412a1` as the shared revision for educational challenges. This needs verification:

1. **Does Maglev exist and function in this revision?** Maglev was enabled by default in Chrome 114 (V8 ~11.4, May 2023). The revision `f5e412a1` is from a later V8 build, so Maglev should be present. This must be validated by building and testing.
2. **Does `%OptimizeMaglevOnNextCall` exist in this revision?** This native function is needed for deterministic Maglev triggering. If not available, the warmup challenge design needs adjustment (e.g., use natural tiering with sufficient invocation counts).
3. **Can the allocation folding bug be cleanly patched into this revision?** The `TryBuildFindNonDefaultConstructorOrConstruct` function and `current_raw_allocation_` field must exist in `maglev-graph-builder.cc` at this revision. If Maglev's architecture changed significantly between this revision and the CVE-affected versions, the patch may not apply cleanly.

**Mitigation:** If the shared revision is incompatible, use a dedicated REVISION file (as level-7e and level-8a already do) pointing to a Maglev-compatible V8 commit. This is the same pattern used for the existing CVE-real challenges.

### CVE-2024-4947 V8 Revision

This challenge requires ES module support in d8. The `--harmony-import-assertions` flag or equivalent must be available. The original vulnerable V8 version (pre-Chrome 125) supports modules natively, but the d8 module loading mechanism (`--module` flag or dynamic `import()`) must be tested.

### GC Reliability

Allocation folding bugs are inherently tied to GC timing. The exploit tests should use retry loops (10–20 attempts) consistent with existing GC-dependent challenges (levels 7b, 7c, 6g, 6h). The proof-lab challenge (maglev-2) should use `gc()` for deterministic GC if `--expose-gc` is available, or allocation pressure patterns otherwise.

### Build Time

Each new challenge directory with a unique patch requires a V8 rebuild. Since all educational challenges share the same REVISION, Docker layer caching means only the incremental `git apply && ninja` step differs. The CVE-real challenges (cve-2024-0517-real, cve-2024-4947) require builds from different V8 revisions and will be the most expensive.

---

## References

- [Exodus Intelligence: CVE-2024-0517 Analysis](https://blog.exodusintel.com/2024/01/19/google-chrome-v8-cve-2024-0517-out-of-bounds-write-code-execution/) — primary technical reference for allocation folding exploitation
- [Matteo Malvica: Chrome Exploitation — Maglev Edition](https://www.matteomalvica.com/blog/2024/06/05/intro-v8-exploitation-maglev/) — pedagogical reference for CVE-2023-4069 (incomplete init)
- [buptsb: CVE-2024-4947 Analysis](https://buptsb.github.io/blog/post/CVE-2024-4947-%20v8%20incorrect%20AccessInfo%20for%20module%20namespace%20object%20causes%20Maglev%20type%20confusion.html) — module namespace type confusion
- [Kaspersky: Lazarus APT DeTankZone Campaign](https://securelist.com/lazarus-apt-steals-crypto-with-a-tank-game/114282/) — CVE-2024-4947 ITW exploitation context
- [V8 Blog: Maglev — V8's Fastest Optimizing JIT](https://v8.dev/blog/maglev) — architecture reference
- [GitHub Security Lab: CVE-2023-4069](https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incomplete-object-initialization-in-the-maglev-compiler/) — incomplete init exploitation
- [Chromium CL 5173470: CVE-2024-0517 fix](https://chromium-review.googlesource.com/c/v8/v8/+/5173470) — allocation folding patch
- [bjrjk/CVE-2024-4947 PoC](https://github.com/bjrjk/CVE-2024-4947) — public proof-of-concept
