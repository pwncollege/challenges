# V8 Exploitation Challenge Suite: Independent Gap Analysis (v2)

**Date:** 2026-02-16
**Analyst:** Independent review via systematic codebase audit
**Scope:** All 57 challenges in `challenges/v8-exploitation/`

---

## 1. Full Challenge Inventory

### Section 1: V8 Heap Exploitation Primitives (15 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 1 | level-1 | Direct Shellcode Execution | Shellcode as IEEE 754 doubles, RWX `Array.prototype.run()` | run() builtin | common |
| 2 | level-1a | Guided ArrayBuffer Layout Warmup | ArrayBuffer backing_store layout, pointer compression | GetAddressOf, ArbRead32, ArbWrite32, AllocRWX, CallRWX, GetArrayBufferBackingStoreOffset | common |
| 3 | level-1b | Heap Navigation and BackingStore Pivot | Full heap R/W via backing_store corruption, 64-bit address handling | GetAddressOf, ArbRead32, ArbWrite32 | common |
| 4 | level-1c | ROP Primer with Libc Helper | ROP chain construction, `__environ` stack discovery | GetAddressOf, ArbRead32, ArbWrite32, GetLibcBase | common |
| 5 | level-2 | Arbitrary Heap Read/Write Primitives | Full libc discovery chain (code ptr -> d8 base -> GOT -> libc) | GetAddressOf, ArbRead32, ArbWrite32 | common |
| 6 | level-2b | Fake Object Construction with ArbRead32 | Fake V8 object construction, BigInt as memory | GetAddressOf, GetFakeObject, ArbRead32 | common |
| 7 | level-3 | Fake Object via Addrof/Fakeobj | addrof/fakeobj primitive pair without direct memory access | GetAddressOf, GetFakeObject | common |
| 8 | level-3b | OOB with Address-Guided Search | OOB via setLength(), guided heap scanning | GetAddressOf, setLength() builtin | common |
| 9 | level-4 | setLength OOB Primitive | Blind OOB scanning without address oracle | setLength() builtin only | common |
| 10 | level-5 | Off-by-One to Full OOB | Off-by-one escalation to full OOB via heap layout prediction | offByOne() builtin | common |
| 11 | level-6 | Callback TOCTOU via functionMap | Callback re-entrancy during iteration (TOCTOU), stale pointer | functionMap() builtin | common |
| 12 | level-6e | WASM RWX Shellcode Primer | WASM RWX page exploitation alternative to ROP | oob() builtin, GetAddressOf | common |
| 13 | level-6d | Concat Fast-Path Re-Entrancy | Proof lab: stale-length in concat fast paths via valueOf re-entrancy | WinConcatOob helper | common |
| 14 | cve-2021-21225 | CVE-2021-21225 | Real CVE: concat OOB via TypedArray callback, fake object construction | None (real CVE patch revert) | common |
| 15 | cve-2021-21225-real | CVE-2021-21225 (real V8) | Same CVE on original V8 9.0.x, dynamic offset discovery, WASM RWX | None | 462fc27 |

### Section 2: JIT Bugs on the V8 Heap (8 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 16 | level-6-warmup | JIT Compilation Bridge | JIT element-kind confusion with map check removal, deterministic opt | --allow-natives-syntax, GetAddressOf, GetFixedDoubleArrayMap | common |
| 17 | level-6a | Easy JIT + Easy Heap | Same JIT confusion, removes map constant helper | --allow-natives-syntax, GetAddressOf | common |
| 18 | level-6b | Deterministic JIT + Blind Heap | Blind heap scanning with JIT trigger | --allow-natives-syntax only | common |
| 19 | level-6c | Natural JIT Warmup + Addrof | Natural warmup (~900k iterations), no natives syntax | GetAddressOf | common |
| 20 | level-7 | Natural JIT + Blind Heap Capstone | Full hard mode: natural warmup + blind heap | None | common |
| 21 | level-7e | Reflect.construct + Proxy Placement Lab | Bridge: Proxy get trap side-effects, one-shot corruption placement | WinReflectProxyOob helper | f5e412a |
| 22 | cve-2020-6418 | CVE-2020-6418 | Real CVE (0-day ITW): Turbofan InferMapsUnsafe side-effect modeling | None | f5e412a |
| 23 | cve-2020-6418-real | CVE-2020-6418 (real V8) | Same on original V8 8.0.x | None | bdaa7d6 |

### Section 3: Maglev Compiler Exploitation (7 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 24 | maglev-warmup | Compilation Observation Lab | Maglev vs TurboFan compilation tiers, optimization status flags | --allow-natives-syntax, WinMaglevObserved | e73f620 |
| 25 | maglev-1 | Incomplete Object Initialization | Maglev BuildAllocateFastObject skips element init, info leak | WinUninitializedField | e73f620 |
| 26 | maglev-2 | Allocation Folding Proof Lab | Allocation folding across super() boundary, GC interaction | WinAllocationFolding | e73f620 |
| 27 | maglev-3 | GC-Triggered OOB via Allocation Folding | Weaponized stale offset after GC relocation | GetAddressOf, WinOOBWrite | e73f620 |
| 28 | cve-2024-0517 | CVE-2024-0517 | Maglev allocation folding OOB write, WASM RWX endgame | GetAddressOf | e73f620 |
| 29 | cve-2024-0517-real | CVE-2024-0517 (no helpers) | Same CVE without helpers or native syntax | None | d8fd818 |
| 30 | cve-2024-4947 | CVE-2024-4947 | Maglev module namespace type confusion (Lazarus Group 0-day) | None | 4733183 |

### Section 4: Garbage Collection Internals (3 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 31 | level-6f-warmup | GC Observation Lab | NewSpace->OldSpace promotion, WeakRef collection detection | GetObjectSpaceTag, WinPromotion, WinCollection | common |
| 32 | level-6g | GC-Triggered UAF (Proof Lab) | GC-triggered backing store free, unsorted bin fd/bk leak | oob() builtin, WinGcUaf | common |
| 33 | level-6h | GC Exploitation Capstone | Full GC UAF + unsorted bin leak + libc ROP | oob() builtin, GetLibcBase | common |

### Section 5: V8 Debugging Challenges (2 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 34 | level-6i | DebugPrint Offset Discovery | %DebugPrint() for runtime object inspection, offset discovery | CreateVault, WinDebugPrint | common |
| 35 | level-6j | JIT Optimization Trace | %OptimizeFunctionOnNextCall(), %GetOptimizationStatus() | WinJitTrace | common |

### Section 6: JIT Bugs on the Malloc Heap (10 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 36 | level-7-warmup | Malloc Heap BackingStore Primer | DataView OOB, BackingStore deleter layout | GetLibcBase + BackingStore layout helpers | common |
| 37 | level-7a | DataView OOB with Libc Helper | DataView byte-granular OOB, malloc heap navigation | GetLibcBase | common |
| 38 | level-7b | Unsorted Bin Leak with Sync GC | Unsorted bin pointer leak via gc()-triggered free | gc() function | common |
| 39 | level-7c-warmup | Async-GC Reliability | WeakRef/weak-callback patterns, event loop GC control | RegisterWeak, WasCollected, WinAsyncGC | common |
| 40 | level-7c | Unsorted Bin Leak with Async GC | Full difficulty malloc heap exploitation with async GC | None | common |
| 41 | level-7d | Subtle Bounds Bug with Sync GC | Subtle compiler range analysis bug (Min vs Max) | gc() function | common |
| 42 | level-8 | Subtle Bounds Bug with Async GC | Same bug, async GC, full difficulty capstone | None | common |
| 43 | level-8c | Typer Mismatch Arithmetic (Proof Lab) | Typer prediction vs runtime value divergence | WinTyperMismatch | f5e412a |
| 44 | cve-2020-16040 | CVE-2020-16040 | Real CVE: simplified lowering integer overflow, typer hardening bypass | None | f5e412a |
| 45 | cve-2020-16040-real | CVE-2020-16040 (real V8) | Same on original V8 | None | 1a37d56 |

### Section 7: Escaping the V8 Sandbox (12 challenges)

| # | ID | Name | Teaches | Helpers Provided | V8 Rev |
|---|-----|------|---------|-----------------|--------|
| 46 | level-8-warmup | Sandbox + WASM Pivot Primer | Sandbox architecture, MemoryCorruptionApi, WASM memory_start | WASM offset helpers, getLibcBase | f5e412a |
| 47 | level-8a | Sandbox with Libc Helper | Full sandbox escape via WASM memory_start + ROP | Sandbox.getLibcBase | f5e412a |
| 48 | level-8b | Sandbox Pivot with D8 Base Helper | GOT-based libc discovery from d8 base | Sandbox.getD8Base | f5e412a |
| 49 | level-9 | Sandbox Escape Without Helpers | Full sandbox escape capstone, multi-strategy libc discovery | MemoryCorruptionApi only | f5e412a |
| 50 | level-9a | Regexp Bytecode Bridge | Regexp bytecode register corruption, stack write primitive | Regexp offset helpers | f5e412a |
| 51 | level-9c | Sandbox GOT-Overwrite Bridge | ELF/GOT parsing, GOT entry overwrite technique | GetD8Base, ReadPtr, WritePtr, DlsymAddr | f5e412a |
| 52 | cve-2023-2033 | CVE-2023-2033 | Real CVE (ITW): WasmIndirectFunctionTable corruption, GOT overwrite | MemoryCorruptionApi | f5e412a |
| 53 | cve-2023-2033-real | CVE-2023-2033 (real V8) | Same on original V8 | None | f7a3499 |
| 54 | level-9b | GSAB Underflow Bridge | GSAB signed-to-unsigned underflow, read-only OOB exploitation | gsabUnderflowRead64, GOT/libc helpers | f5e412a |
| 55 | level-9d | Wasm RWX Hunting / Jump-Table Patch | RWX page discovery via write-read-restore, jump table patching | AllocRWX, IsExecutable, GetJumpSlotAddr | f5e412a |
| 56 | cve-2024-2887 | CVE-2024-2887 | Pwn2Own 2024: WASM RWX shellcode injection sandbox escape | MemoryCorruptionApi | f5e412a |
| 57 | cve-2024-2887-real | CVE-2024-2887 (real V8) | Same on original V8 | None | f0b4342 |

---

## 2. Difficulty Progression Map

### Difficulty Tiers

```
Tier 1 (Beginner):
  level-1 ─────────────── Direct shellcode execution, trivial
  maglev-warmup ─────────  Observe JIT tiers, no exploitation
  level-6f-warmup ──────── Observe GC behavior, no exploitation
  level-6i ─────────────── DebugPrint offset discovery
  level-6j ─────────────── JIT optimization control

Tier 2 (Guided):
  level-1a ──────────────── ArrayBuffer layout with full helpers
  level-1b ──────────────── Backing store pivot with helpers
  level-1c ──────────────── ROP with libc helper
  maglev-1 ──────────────── Observe uninitialized memory
  maglev-2 ──────────────── Prove allocation folding
  level-6d ──────────────── Prove concat re-entrancy
  level-6e ──────────────── WASM RWX with OOB+addrof helpers
  level-7e ──────────────── Reflect.construct trigger placement
  level-8c ──────────────── Typer mismatch proof
  level-7c-warmup ─────── Async GC mechanics
  level-6-warmup ─────────  JIT confusion with all helpers

Tier 3 (Intermediate):
  level-2 ────────────────── Full libc discovery, helpers for read/write
  level-2b ──────────────── Fake object construction
  level-3 ────────────────── Fake object pair (addrof/fakeobj)
  level-3b ──────────────── OOB with address-guided scanning
  level-6a ──────────────── JIT + heap with some helpers
  level-6b ──────────────── JIT + blind heap scanning
  level-6c ──────────────── Natural JIT warmup
  level-6g ──────────────── GC UAF proof lab
  level-7-warmup ─────────  Malloc heap with layout helpers
  level-9a ──────────────── Regexp bytecode bridge
  level-9c ──────────────── GOT overwrite bridge
  level-9d ──────────────── RWX hunting bridge
  level-9b ──────────────── GSAB underflow bridge
  maglev-3 ──────────────── GC-triggered OOB (bridging)

Tier 4 (Hard):
  level-4 ────────────────── Blind OOB without address oracle
  level-5 ────────────────── Off-by-one escalation
  level-6 ────────────────── Callback TOCTOU re-entrancy
  level-7 ────────────────── Natural JIT + blind heap capstone
  level-7a ──────────────── DataView OOB, malloc heap
  level-7b ──────────────── Unsorted bin leak, sync GC
  level-7d ──────────────── Subtle bounds bug, sync GC
  level-6h ──────────────── GC exploitation capstone
  level-8-warmup ─────────  Sandbox intro with helpers
  level-8a ──────────────── Sandbox escape, libc helper
  level-8b ──────────────── Sandbox escape, d8 base helper
  cve-2024-0517 ─────────── Maglev alloc folding OOB

Tier 5 (Expert):
  level-7c ──────────────── Async GC, full difficulty
  level-8 ────────────────── Async GC subtle bug capstone
  level-9 ────────────────── Sandbox escape, no helpers
  cve-2020-6418 ─────────── ITW 0-day type confusion
  cve-2021-21225 ─────────── Real CVE concat OOB
  cve-2020-16040 ─────────── Real CVE typer overflow
  cve-2023-2033 ─────────── Real CVE sandbox escape
  cve-2024-2887 ─────────── Pwn2Own sandbox escape
  cve-2024-4947 ─────────── Lazarus Group 0-day
  cve-2024-0517-real ─────── Real CVE, no helpers

Tier 6 (Master):
  cve-2020-6418-real ─────── Original V8, different offsets
  cve-2021-21225-real ────── Original V8, dynamic scanning
  cve-2020-16040-real ────── Original V8
  cve-2023-2033-real ─────── Original V8
  cve-2024-2887-real ─────── Original V8
```

### Difficulty Cliff Assessment

**Cliff 1 (Minor): level-1 -> level-1a**
level-1 requires zero V8 knowledge (just shellcode encoding). level-1a immediately requires understanding pointer compression, ArrayBuffer internals, and backing_store layout. The helpers soften this, but it's still a conceptual jump. **Verdict: Adequately bridged.**

**Cliff 2 (Moderate): level-3 -> level-4**
level-3 has GetAddressOf+GetFakeObject helpers. level-3b adds setLength with GetAddressOf. level-4 strips all address helpers leaving only setLength. The blind scanning required is a significant step up. **Verdict: level-3b partially bridges this, but could use more scaffolding.**

**Cliff 3 (Minor): level-6 -> level-6-warmup (JIT)**
Transitioning from runtime callback bugs to JIT compiler bugs is a mental model shift. level-6-warmup exists specifically to bridge this. **Verdict: Well bridged.**

**Cliff 4 (Moderate): V8 heap -> Malloc heap (level-7 series)**
Moving from V8 heap manipulation to malloc heap exploitation (BackingStore, unsorted bins, deleter corruption) introduces entirely new concepts. level-7-warmup bridges this. **Verdict: Adequately bridged but the malloc heap concepts are fundamentally different enough that students may struggle.**

**Cliff 5 (Significant): Pre-sandbox -> Sandbox (level-8 series)**
The sandbox fundamentally changes the threat model. Everything learned about backing_store corruption becomes invalid. The MemoryCorruptionApi is a new abstraction. WASM memory_start pivot is a novel technique. level-8-warmup exists but the conceptual jump is large. **Verdict: Multiple bridge levels help, but this is the hardest transition in the suite.**

**Cliff 6 (Minor): Backported CVE -> Real V8 CVE**
Each CVE has a `-real` variant on the original V8. Different offsets, heap layouts, and sometimes different endgame techniques. **Verdict: Well designed -- the backported version serves as the bridge.**

---

## 3. Identified Gaps (Prioritized)

### Priority 1 (Critical Gaps)

#### Gap 1.1: No Turboshaft/Turbofan IR Visualization or Analysis Challenges
The JIT section (levels 6-warmup through 7, CVE-2020-6418) has students exploit JIT bugs but never requires them to **read or understand the IR graph**. In real vulnerability research, understanding Turbofan's Sea of Nodes IR, the reduction pipeline (Typer -> Simplified Lowering -> Effect Control Linearization), and how to use `--trace-turbo` is essential.

**What's missing:** A challenge where the student must:
- Use `--trace-turbo` to dump the IR graph
- Identify the optimization pass where the bug manifests
- Understand node types (CheckMaps, NumberAdd, SpeculativeNumberAdd, etc.)
- Trace how type information flows through the graph

**Why it matters:** CVE analysis and variant hunting require reading IR, not just triggering bugs empirically.

#### Gap 1.2: No Sparkplug Coverage
The compilation pipeline is covered as: Ignition (interpreter) -> Maglev -> TurboFan/Turboshaft. **Sparkplug** (the baseline compiler that sits between Ignition and Maglev) is entirely absent. While Sparkplug bugs are rarer, understanding where it sits in the pipeline is important for completeness, and Sparkplug-specific bugs do exist.

#### Gap 1.3: No Coverage of V8 Sandbox Hardening Post-2024
The sandbox escape challenges all exploit the `memory_start` raw pointer in `WasmInstanceObject`. The writeups explicitly note this is an **older sandbox design weakness** and that "newer V8 builds have moved `memory_start` to more protected storage."

**What's missing:**
- Challenges targeting the External Pointer Table (EPT) itself
- Code Pointer Table attacks
- Trusted Pointer Table bypasses
- Challenges where `memory_start` is protected and students must find alternative escape vectors
- Coverage of the "Code Pointer Sandboxing" (`v8_code_pointer_sandboxing`) that is explicitly disabled in `args.gn`

**Why it matters:** The current sandbox escape technique (`memory_start` pivot) has been largely mitigated in modern V8. Students completing this module would struggle with a 2025+ Chrome target.

#### Gap 1.4: No Vulnerability Discovery Methodology
Every challenge provides the patch (or reverts a known fix). Students never have to **find** a vulnerability themselves. There is no challenge that provides an unfamiliar codebase/patch and asks students to identify what's wrong.

**What's missing:**
- "Find the bug" challenges where the vulnerability isn't labeled
- Fuzzing methodology (structure-aware fuzzing, coverage-guided fuzzing of V8)
- Variant analysis: given one CVE, find similar patterns
- Differential testing between tiers (interpreter vs JIT output comparison)

### Priority 2 (Important Gaps)

#### Gap 2.1: No Integer/Type Confusion Beyond Element-Kind
Almost all JIT-section type confusions are element-kind confusion (PACKED_DOUBLE vs PACKED_ELEMENTS stride mismatch). The only arithmetic type confusion is CVE-2020-16040 (typer mismatch). Missing:
- Range narrowing bugs (SpeculativeNumberAdd producing values outside the Typer's predicted range)
- Type widening issues (Signed32 -> Unsigned32 -> Float64 transitions)
- Object/primitive type confusions beyond array element kinds
- Map transition confusion (hidden class violations)

#### Gap 2.2: Missing Major CVE Classes (2023-2025)

**CVEs that are covered:**
- CVE-2020-6418 (Turbofan InferMapsUnsafe) -- ITW 0-day
- CVE-2020-16040 (Simplified lowering integer overflow)
- CVE-2021-21225 (Array.prototype.concat OOB)
- CVE-2023-2033 (sandbox escape via WasmIndirectFunctionTable)
- CVE-2024-0517 (Maglev allocation folding)
- CVE-2024-2887 (Pwn2Own WASM type confusion)
- CVE-2024-4947 (Maglev module namespace -- Lazarus)

**Important CVEs NOT covered:**
- **CVE-2023-3079** (V8 type confusion, ITW 0-day, June 2023) -- One of the most exploited Chrome 0-days
- **CVE-2023-4762** (V8 type confusion, ITW 0-day, September 2023) -- Used by Intellexa/Predator
- **CVE-2024-5274** (V8 type confusion, ITW 0-day, May 2024) -- Used by NSO Group; the last major pre-sandbox-hardening bug
- **CVE-2024-7965** (V8 inappropriate implementation in V8, ITW August 2024) -- Widely exploited
- **CVE-2023-6345** (Skia integer overflow used in Chrome exploit chain, Nov 2023) -- Illustrates renderer -> sandbox escape chain
- No coverage of **WebAssembly** JIT compilation bugs (beyond WASM as an escape vehicle)

#### Gap 2.3: No Multi-Stage Exploit Chain
Real Chrome exploitation requires: renderer bug -> sandbox escape -> kernel/OS exploit. Every challenge in this suite is a single-stage exercise (either a V8 heap bug OR a sandbox escape, never both chained together).

**What's missing:** A capstone challenge that combines:
1. A JIT type confusion to gain intra-sandbox corruption
2. A sandbox escape technique to achieve code execution

Even a simplified 2-stage chain would be valuable pedagogically.

#### Gap 2.4: Repetitive Endgame Techniques
The suite teaches three endgame techniques:
1. **ROP chain** via libc's `__environ` -> stack -> return address overwrite (used by ~30 challenges)
2. **GOT overwrite** (CVE-2023-2033)
3. **WASM RWX shellcode injection** (CVE-2024-2887, level-6e, cve-2021-21225-real)

**Missing endgame techniques:**
- **JIT spray** / JIT-ROP (constructing code gadgets from JIT output)
- **COOP/COUNTERFEIT** (calling existing engine functions with controlled arguments)
- **Signal handler hijacking**
- **File descriptor manipulation** (V8 runs in a renderer sandbox, FD manipulation is relevant)
- **Chrome-specific**: Mojo IPC abuse for sandbox escape

#### Gap 2.5: No WebAssembly Internals
WASM appears only as a sandbox escape vehicle (RWX pages, memory_start). There are no challenges about:
- WASM JIT compilation bugs
- WASM type system confusion (the actual CVE-2024-2887 bug mechanism, not just the escape)
- WASM stack/linear memory interactions
- WASM module loading and validation bugs

### Priority 3 (Nice-to-Have Gaps)

#### Gap 3.1: No Pointer Compression Deep Dive
Pointer compression (cage base + 32-bit offset) is used throughout but never explicitly taught. A challenge that requires understanding or manipulating the compression scheme directly would be valuable.

#### Gap 3.2: No Race Condition / Concurrent Exploitation
V8 is increasingly concurrent (concurrent compilation, concurrent GC marking). No challenges explore race conditions between the main thread and compiler/GC threads.

#### Gap 3.3: No PAC/CET/MTE Bypass Challenges
Modern hardware mitigations (ARM Pointer Authentication, Intel CET shadow stacks, ARM MTE) are not addressed. These are increasingly relevant for real-world exploitation on mobile/desktop.

#### Gap 3.4: No Cross-Browser Perspective
Understanding how V8's bugs compare to SpiderMonkey (Firefox) or JavaScriptCore (Safari) JIT bugs would broaden the student's perspective. This is understandably out of scope for a V8-focused module.

#### Gap 3.5: Limited Coverage of Torque/CSA Builtins
The challenges modify `builtins-array.cc` (C++ builtins) and compiler passes. No challenges touch Torque-defined builtins or CodeStubAssembler, which are where many modern V8 builtins live.

---

## 4. Quality Assessment

### 4.1 Descriptions

**Module-level description:** Minimal (8 lines in DESCRIPTION.md). Adequate as a brief intro but could benefit from a learning roadmap or prerequisite list.

**Challenge descriptions in module.yml:** Mixed quality.
- **Good:** Warmup, bridge, and CVE challenges have specific, informative descriptions that tell students what they'll learn.
- **Poor:** 19 challenges use the generic description "Reference the included patch file to exploit the javascript engine!" This is unhelpful -- it doesn't tell students what's new about this challenge vs. the previous one. Specific examples: level-1b, level-1c, level-2, level-2b, level-3, level-3b, level-4, level-5, level-6, level-6a, level-6b, level-6c, level-7, level-7a, level-7b, level-7c, level-7d, level-8, level-8a, level-8b, level-9.

**Recommendation:** Every challenge should have a unique description that tells the student what distinguishes it from surrounding challenges.

### 4.2 Writeups

**Coverage:** Every challenge (57/57) has a `tests_private/WRITEUP.md`. This is impressive.

**Quality range:**
- **Exceptional (A+):** CVE-2020-6418 (132 lines, phase-by-phase, references), CVE-2024-2887 (118 lines), level-9 (93 lines), level-7 (7074 bytes). These are reference-grade exploitation writeups with vulnerability analysis, exploitation strategy, gotchas, and external references.
- **Very good (A):** Most challenges have 50-100 line writeups with clear vulnerability description, solve outline, and gotchas.
- **Adequate (B):** Bridge/proof labs (level-6d, level-7e, maglev-1, level-6-warmup) have shorter writeups (30-50 lines) but are still clear.
- **None rated below B.** The writeup quality is consistently high across the entire suite.

### 4.3 Patches

**Coverage:** Every challenge (57/57) has a patch file.

**Quality:**
- Clean, readable diffs that clearly show the vulnerability
- CVE challenges cleanly revert the specific fix
- Synthetic challenges add well-structured custom builtins
- The d8 shell hardening (commenting out utility functions) is applied consistently
- Patch sizes range from ~1.8KB (minimal CVE reverts) to ~7KB (challenges with multiple helper builtins)

**Concern:** The d8 hardening pattern (commenting out `print`, `readline`, `quit`, etc.) is duplicated in every single patch file. This could be factored into a common patch applied in the Dockerfile, reducing patch noise.

### 4.4 Tests

**Coverage:** Every challenge has both `tests_public/test_basic.sh` and `tests_private/test_exploit.sh`.

**Public tests:** Minimal -- typically just `echo 'console.log("ok");' | d8 | grep ok`. Sufficient to verify the build works but tests nothing challenge-specific.

**Private tests:** Full exploit scripts (20-550 lines of JavaScript wrapped in bash). These are essentially reference solutions. Quality is high -- they include retry loops for heap nondeterminism, error handling, and clear comments.

**Concern:** The private tests/solutions are shell scripts that embed JavaScript via heredocs. This makes them harder to debug than standalone .js files. Some challenges (level-2, level-3) have multiple test files (test_exploit.sh + test_solve.sh / test_exhaustive.sh), which is good for coverage.

### 4.5 Build Infrastructure

**V8 Revisions:**
- **Common base:** `5a2307d` -- used by ~30 challenges (levels 1-8 without sandbox)
- **Sandbox-era:** `f5e412a` -- used by ~15 sandbox/bridge challenges
- **Maglev-era:** `e73f620` -- used by 6 Maglev challenges
- **CVE-specific:** 6 additional revisions for `-real` variants + CVE-2024-4947
- **Total:** 9 distinct V8 revisions

This is well-designed. The common base means most challenges share Docker layer caching, with incremental builds for patches. The `-real` variants use different revisions for authenticity.

**Concern:** Building 9 different V8 versions is extremely time-consuming. The multi-stage Dockerfile is well-optimized (baseline build cached, patches applied incrementally), but initial cold builds will take hours.

### 4.6 Missing Components

**DESCRIPTION.md:** No challenge has a `challenge/DESCRIPTION.md` file. The only descriptions are in `module.yml` entries. This means students see the description only in the web UI, not when browsing the filesystem. For challenges with generic descriptions, this is particularly problematic -- there's no local documentation of what the challenge is about.

**README or learning resources:** No per-challenge README files. No links to relevant V8 documentation, blog posts, or academic papers within the challenge directories (though the writeups include references).

---

## 5. Specific Recommendations

### Immediate (High Impact, Low Effort)

1. **Replace generic descriptions.** The 19 challenges using "Reference the included patch file..." should each get a unique 1-2 sentence description that tells students what new concept or removed helper distinguishes this challenge. This is a module.yml-only change.

2. **Add a curriculum map.** Create a visual progression document (can be ASCII art or mermaid diagram) showing the dependency graph between challenges. Students currently have no way to know that level-6-warmup bridges to level-6a, or that level-8c is a proof lab for CVE-2020-16040.

3. **Add prerequisite annotations.** In module.yml, add a `prerequisites` field to each challenge listing which prior challenges should be completed first.

### Medium-Term (Moderate Effort)

4. **Add IR visualization challenges.** Create 2-3 challenges focused on `--trace-turbo` / `--trace-turbo-graph` / Turbolizer that require students to:
   - Identify which optimization pass introduces the bug
   - Read the Sea of Nodes graph
   - Trace type information through the IR

5. **Add a "find the bug" challenge.** Provide a patched V8 binary (with a synthetic vulnerability) and ask students to find the vulnerability by diffing, fuzzing, or code review -- without providing the patch file.

6. **Add a 2-stage exploit chain.** Create a capstone that chains a V8 heap corruption (JIT type confusion) with a sandbox escape, requiring students to combine techniques from different sections.

7. **Update sandbox escape techniques.** Add challenges for post-2024 sandbox designs where `memory_start` is protected. Explore alternative escape vectors:
   - Corrupting Code Pointer Table entries
   - External Pointer Table type confusion
   - Trusted space corruption

### Long-Term (High Effort)

8. **Add missing CVE coverage.** Prioritize:
   - CVE-2024-5274 (last major pre-hardening ITW 0-day)
   - CVE-2024-7965 (widely exploited, 2024)
   - CVE-2023-3079 (one of the most exploited Chrome 0-days)
   At minimum, a backported version of each with a bridge challenge.

9. **Add WASM JIT bug challenges.** Create challenges about WASM compilation bugs (type confusion in WASM type validation, Liftoff/TurboFan WASM compilation bugs) rather than using WASM only as a sandbox escape vehicle.

10. **Add fuzzing methodology.** Create a challenge where students must:
    - Set up a V8 fuzzer (or use Fuzzilli)
    - Find a synthetic bug via coverage-guided fuzzing
    - Triage and exploit the discovered crash

11. **Add concurrent exploitation.** Create a challenge involving a race condition between the main thread and concurrent compilation or concurrent GC marking.

### Infrastructure Improvements

12. **Factor out d8 hardening.** The d8 shell function commenting is duplicated across all 57 patches. Extract it into a common patch applied in the Dockerfile, so challenge-specific patches only contain the vulnerability.

13. **Add per-challenge DESCRIPTION.md files.** Even if just a copy of the module.yml description + a pointer to relevant V8 docs, this helps students browsing the filesystem.

14. **Improve public tests.** The current `console.log("ok")` test verifies the build but nothing challenge-specific. Add tests that verify the patch's observable behavior (e.g., for level-1: verify `Array.prototype.run` exists; for JIT levels: verify the patch changes JIT behavior).

---

## 6. What a Graduate Would Still Not Know

After completing all 57 challenges, a student would be proficient in:
- V8 heap object layout and exploitation primitives (addrof/fakeobj, OOB, backing_store corruption)
- JIT type confusion via element-kind mismatch
- Maglev compiler internals and allocation folding bugs
- GC internals and UAF exploitation
- Libc exploitation (unsorted bin leak, ROP chains, GOT overwrite)
- Sandbox architecture and memory_start pivot escape
- Adapting exploits across V8 versions

A student would **still not know**:
1. **How to find V8 bugs** -- all bugs are provided as patches
2. **How to read Turbofan IR** -- no challenge requires it
3. **Modern sandbox escape techniques** (post-2024 hardening)
4. **Chrome-specific exploitation** (Mojo IPC, renderer process restrictions, site isolation)
5. **WASM internals** beyond using RWX pages
6. **Hardware mitigations** (CET, PAC, MTE) and how to work around them
7. **Multi-stage exploit chains** combining renderer + sandbox escape
8. **Exploitation reliability engineering** beyond retry loops
9. **How to fuzz V8** or do variant analysis
10. **Concurrent/race condition exploitation** in V8

The suite is excellent for teaching V8 heap exploitation mechanics and historical CVE reproduction. It is weaker on vulnerability discovery methodology, modern defenses, and the broader Chrome exploitation pipeline. A student completing this module would be well-prepared to reproduce known V8 bugs but would need significant additional training to discover and exploit new ones in modern Chrome.
