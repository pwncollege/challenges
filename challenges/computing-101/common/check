#!/usr/bin/exec-suid --real -- /bin/python3 -I

import os
os.environ["PATH"] = "/challenge/bin:/bin:/usr/bin:/usr/local/bin"
os.environ["TERM"] = "xterm-256color"

import pwnlib.tubes.process
import subprocess
import capstone
import tempfile
import socket
import time
import rich
import sys

cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)

sys.path.append(os.path.dirname(__file__)+"/.py")
import chal #pylint:disable=import-error,wrong-import-position

class ChallengeFailed(Exception):
    pass
class ChallengeFailedPrint(ChallengeFailed):
    pass

def print_prompt():
    print(f"""hacker@{socket.gethostname()}:{
        os.getcwd().replace(os.path.expanduser('~'), '~', 1)
    }$ """, end="", flush=True)

def slow_pause():
    if "FAST" not in os.environ:
        time.sleep(0.05)

def slow_print(what):
    for c in what:
        print(c, end="", flush=True)
        slow_pause()
    print("")

def dramatic_command(command, stdin=None, actual_command=None):
    print_prompt()
    slow_print(command)
    if not stdin:
        exit_code = os.WEXITSTATUS(
            os.system(command if actual_command is None else actual_command)
        )
    else:
        p = pwnlib.tubes.process.process(
            command if actual_command is None else actual_command,
            shell=True
        )
        slow_pause()
        slow_print(stdin.decode())
        time.sleep(0.05)
        p.write(stdin)
        p.shutdown("send")
        p.wait()
        exit_code = p.poll()

    slow_pause()
    return exit_code

def build_input(elf_path, input_file=None):
    raw_path = tempfile.mktemp(prefix="check-raw-")
    cmd = ["builder", "-i", "--output-raw", raw_path, "--output-elf", elf_path]
    if not getattr(chal, "allow_asm", False):
        cmd += ["--reject-asm"]
    if not getattr(chal, "allow_elf", True):
        cmd += ["--reject-elf"]
    if hasattr(chal, "assembly_prefix"):
        cmd += ["--prefix", chal.assembly_prefix]
    if hasattr(chal, "assembly_suffix"):
        cmd += ["--suffix", chal.assembly_suffix]
    if input_file:
        cmd.append(input_file)
    result = subprocess.run(cmd, stderr=subprocess.PIPE)
    if result.returncode != 0:
        error = result.stderr.decode("utf-8", errors="replace").strip()
        if error:
            raise ChallengeFailedPrint(error)
        sys.exit(1)

    #pylint:disable=consider-using-with
    raw_binary = open(raw_path, "rb").read()
    os.unlink(raw_path)
    return raw_binary

console = rich.console.Console(highlight=False)
err_console = rich.console.Console(stderr=True, highlight=False)

def do_check(stage_id, stage_description, *args, **kwargs):
    try:
        if not hasattr(chal, stage_id):
            return None

        print("")
        console.print(getattr(chal, stage_id+"_prologue", f"{stage_description}...").format(**chal.__dict__), style="bold magenta")
        r = getattr(chal, stage_id)(*args, **kwargs)
        console.print(getattr(chal, stage_id+"_success", "... YES! Great job!").format(**chal.__dict__), style="bold green")
        return r
    except (ChallengeFailed, AssertionError) as _e:
        console.print(getattr(chal, stage_id+"_failure", "... oops, we found an issue! Details below:\n").format(**chal.__dict__), style="bold red")
        console.print(str(_e), style="bold red")
        raise

def main():
    elf_filename = getattr(chal, 'final_filename', "/tmp/your-program")
    input_file = sys.argv[1] if len(sys.argv) == 2 else None
    raw_binary = build_input(elf_filename, input_file)

    disas = list(cs.disasm(raw_binary, 0))
    if not disas:
        print("Your binary failed to disassemble.")
        return

    num_instructions = getattr(chal, "num_instructions", None)
    if num_instructions is not None and len(disas) != num_instructions:
        print(
            f"This challenge expects {num_instructions} "
            f"instruction{'s' if num_instructions != 1 else ''}, "
            f"but you provided {len(disas)}."
        )
        return

    do_check("check_raw_binary", "Checking the binary code", raw_binary)
    do_check("check_disassembly", "Checking the assembly code", disas)
    do_check("check_runtime", "Checking runtime behavior", elf_filename)

    if getattr(chal, "give_flag", False):
        print("")
        print("Here is your flag!")
        #pylint:disable=consider-using-with,unspecified-encoding
        print(open("/flag").read())


if __name__ == '__main__':
    try:
        main()
    except (ChallengeFailedPrint) as _e:
        print("Check failed:")
        print()
        console.print(str(_e), style="bold red")
    except (ChallengeFailed, AssertionError):
        # we assume we already printed
        pass
    except Exception as _e: #pylint:disable=broad-exception-caught
        print("Unexpected error during challenge evaluation! The error:")
        print(_e)
        raise
