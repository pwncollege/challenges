{% extends "common/base.c.j2" %}
{% set iterations = 1 %}
{% set initial_breakpoint = true %}
{% set loop_breakpoint = true %}

{% block level_text %}
    puts("You can examine the contents of memory using the `x/<n><u><f> <address>` parameterized command. In this format `<u>` is");
    puts("the unit size to display, `<f>` is the format to display it in, and `<n>` is the number of elements to display. Valid");
    puts("unit sizes are `b` (1 byte), `h` (2 bytes), `w` (4 bytes), and `g` (8 bytes). Valid formats are `d` (decimal), `x`");
    puts("(hexadecimal), `s` (string) and `i` (instruction). The address can be specified using a register name, symbol name, or");
    puts("absolute address. Additionally, you can supply mathematical expressions when specifying the address.\n");
    puts("For example, `x/8i $rip` will print the next 8 instructions from the current instruction pointer. `x/16i main` will");
    puts("print the first 16 instructions of main. You can also use `disassemble main`, or `disas main` for short, to print all of");
    puts("the instructions of main. Alternatively, `x/16gx $rsp` will print the first 16 values on the stack. `x/gx $rbp-0x32`");
    puts("will print the local variable stored there on the stack.\n");
    puts("You will probably want to view your instructions using the CORRECT assembly syntax. You can do that with the command");
    puts("`set disassembly-flavor intel`.\n");
    puts("In order to solve this level, you must figure out the random value on the stack (the value read in from `/dev/urandom`).");
    puts("Think about what the arguments to the read system call are.\n");
{% endblock %}

