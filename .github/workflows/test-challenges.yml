name: Test Challenges

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      test_all:
        description: 'Test all challenges'
        required: false
        default: true
        type: boolean
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-changes: ${{ steps.set-matrix.outputs.has-changes }}

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for proper diff

    - name: Install uv
      uses: astral-sh/setup-uv@v7
      with:
        cache-dependency-glob: ci/list-challenges

    - name: Get challenges to test
      id: changed-challenges
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event_name }}" = "schedule" ]; then
          echo "Testing all challenges (triggered by ${{ github.event_name }})"
          CHALLENGES=$(./ci/list-challenges | tr '\n' ' ')
        else
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
          else
            BASE="${{ github.event.before }}"
            HEAD="${{ github.event.after }}"
          fi

          CHALLENGES=$(./ci/list-challenges --only-modified "$BASE" "$HEAD" | tr '\n' ' ')
        fi

        echo "Challenges to test: $CHALLENGES"
        echo "challenges=$CHALLENGES" >> $GITHUB_OUTPUT

    - name: Set up matrix
      id: set-matrix
      env:
        CHALLENGES: ${{ steps.changed-challenges.outputs.challenges }}
      run: |
        python <<'PY'
        import fnmatch
        import json
        import os
        import pathlib
        import shlex

        repo_root = pathlib.Path(".").resolve()
        challenges_root = repo_root / "challenges"
        changed = [item for item in os.environ.get("CHALLENGES", "").split() if item]
        output_path = pathlib.Path(os.environ["GITHUB_OUTPUT"])

        if not changed:
            with output_path.open("a", encoding="utf-8") as handle:
                handle.write("has-changes=false\n")
                handle.write('matrix={"group":[]}\n')
            raise SystemExit

        def parse_git_crypt_attr(attr_path: pathlib.Path):
            entries = []
            for line in attr_path.read_text(encoding="utf-8").splitlines():
                stripped = line.strip()
                if not stripped or stripped.startswith("#"):
                    continue
                parts = shlex.split(stripped)
                if len(parts) < 2:
                    continue
                pattern, attrs = parts[0], parts[1:]
                for token in attrs:
                    if token.startswith("filter=git-crypt-"):
                        value = token.split("=", 1)[1]
                        entries.append((pattern, value[len("git-crypt-") :]))
            return entries

        def list_challenge_files(challenge_path: pathlib.Path):
            files = [path for path in challenge_path.rglob("*") if path.is_file()]
            if not files:
                # Even if the directory is empty, treat the directory itself as a candidate
                files.append(challenge_path)
            return files

        def find_group(challenge: str) -> str:
            challenge_path = challenges_root / challenge
            if not challenge_path.exists():
                return "default"

            files = list_challenge_files(challenge_path)

            ancestors = []
            current = challenge_path
            while True:
                ancestors.append(current)
                if current == challenges_root or current.parent == current:
                    break
                current = current.parent

            for ancestor in ancestors:
                attr_file = ancestor / ".gitattributes"
                if not attr_file.is_file():
                    continue
                for pattern, group in parse_git_crypt_attr(attr_file):
                    for file_path in files:
                        try:
                            relative = file_path.relative_to(attr_file.parent).as_posix()
                        except ValueError:
                            continue
                        if fnmatch.fnmatch(relative, pattern):
                            return group
            return "default"

        grouped = {}
        for challenge in changed:
            grouped.setdefault(find_group(challenge), []).append(challenge)

        matrix = {
            "group": sorted(grouped),
            "include": [
                {
                    "group": group,
                    "challenges": "\n".join(sorted(set(grouped[group]))),
                }
                for group in sorted(grouped)
            ],
        }

        with output_path.open("a", encoding="utf-8") as handle:
            handle.write("has-changes=true\n")
            handle.write(f"matrix={json.dumps(matrix, separators=(',', ':'))}\n")
        PY

  test-challenges:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue testing other challenges even if one fails
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
    - uses: actions/checkout@v3

    - name: Install uv
      uses: astral-sh/setup-uv@v7
      with:
        cache-dependency-glob: build

    - name: Set up Docker
      uses: docker/setup-buildx-action@v3

    - name: Install git-crypt
      run: |
        sudo apt-get update && sudo apt-get install -y git-crypt

    - name: Remove encrypted directories
      run: |
        # Find and remove directories containing encrypted files using git-crypt status (these cannot be tested currently)
        git crypt status -e | sed -e "s/ *encrypted: //" | xargs dirname | xargs rm -rf

    - name: Test challenges in group
      env:
        GROUP_CHALLENGES: ${{ matrix.challenges }}
        GROUP_NAME: ${{ matrix.group }}
      run: |
        if [ -z "$GROUP_CHALLENGES" ]; then
          echo "No challenges queued for group: $GROUP_NAME"
          exit 0
        fi

        while IFS= read -r challenge; do
          if [ -z "$challenge" ]; then
            continue
          fi

          echo "================================================"
          echo "Group: $GROUP_NAME"
          echo "Testing challenge: $challenge"
          echo "================================================"

          ./build "./challenges/$challenge" 2>&1 | sed "s|^FAILED: /tmp/[^/]*/|::error::TEST FAILED: $challenge/|"

          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "================================================"
            echo "✓ $challenge passed"
            echo "================================================"
          else
            echo "================================================"
            echo "✗ $challenge failed"
            echo "================================================"
            exit 1
          fi
        done <<< "$GROUP_CHALLENGES"
